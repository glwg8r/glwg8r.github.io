<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GlwG8r Nexus - Optimized</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono:wght@400&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Share Tech Mono', monospace;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 50%, #0f1a0f 100%);
            min-height: 100vh;
            overflow: hidden;
            position: relative;
        }
        
        .desktop {
            width: 100vw;
            height: 100vh;
            position: relative;
            background-image: 
                radial-gradient(circle at 20% 80%, rgba(0, 255, 0, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(0, 255, 0, 0.03) 0%, transparent 50%),
                linear-gradient(90deg, rgba(0, 255, 0, 0.01) 1px, transparent 1px),
                linear-gradient(0deg, rgba(0, 255, 0, 0.01) 1px, transparent 1px);
            background-size: 
                800px 800px,
                600px 600px,
                20px 20px,
                20px 20px;
            animation: subtle-pulse 8s ease-in-out infinite;
        }
        
        .gator-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.08;
            pointer-events: none;
            background: 
                radial-gradient(ellipse at 65% 75%, rgba(0, 255, 65, 0.3) 0%, transparent 40%),
                radial-gradient(ellipse at 35% 60%, rgba(255, 0, 65, 0.2) 0%, transparent 30%),
                linear-gradient(45deg, rgba(0, 100, 50, 0.1) 0%, transparent 70%);
            filter: contrast(1.5) brightness(0.7);
        }
        
        .gator-backdrop::before {
            content: '';
            position: absolute;
            top: 20%;
            left: 15%;
            width: 70%;
            height: 60%;
            background: linear-gradient(135deg, 
                rgba(0, 255, 65, 0.15) 0%, 
                rgba(0, 150, 40, 0.1) 30%,
                rgba(255, 100, 0, 0.05) 60%,
                transparent 100%);
            clip-path: polygon(20% 40%, 45% 20%, 70% 35%, 80% 60%, 60% 80%, 30% 85%, 10% 70%);
            animation: gator-pulse 8s ease-in-out infinite;
        }
        
        @keyframes gator-pulse {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(1.02); }
        }
        
        @keyframes subtle-pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
        
        .glyph-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.15;
        }
        
        .nordic-glyph {
            position: absolute;
            color: #00ff41;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px #00ff41;
            animation: glyph-flicker 3s ease-in-out infinite;
        }
        
        @keyframes rune-appear {
            0% { opacity: 0; transform: scale(0.5) rotate(0deg); }
            20% { opacity: 0.3; transform: scale(1.1) rotate(15deg); }
            50% { opacity: 0.2; transform: scale(1) rotate(0deg); }
            80% { opacity: 0.25; transform: scale(0.95) rotate(-10deg); }
            100% { opacity: 0; transform: scale(0.7) rotate(5deg); }
        }
        
        .hypnotic-rune {
            position: absolute;
            color: #00ff41;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 0 0 15px #00ff41, 0 0 25px #00ff41;
            pointer-events: none;
            animation: rune-appear ease-in-out;
        }
        
        .scan-lines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 255, 0, 0.03) 2px,
                rgba(0, 255, 0, 0.03) 4px
            );
            animation: scan-move 2s linear infinite;
            pointer-events: none;
        }
        
        @keyframes scan-move {
            0% { transform: translateY(0); }
            100% { transform: translateY(4px); }
        }
        
        .terminal-corners {
            position: absolute;
            color: #00ff41;
            font-size: 16px;
            text-shadow: 0 0 5px #00ff41;
            font-weight: bold;
        }
        
        .corner-tl { top: 20px; left: 20px; }
        .corner-tr { top: 20px; right: 20px; }
        .corner-bl { bottom: 20px; left: 20px; }
        .corner-br { bottom: 20px; right: 20px; }
        
        .data-stream {
            position: absolute;
            top: 50px;
            right: 30px;
            color: #00ff41;
            font-size: 10px;
            line-height: 1.2;
            opacity: 0.6;
            text-shadow: 0 0 3px #00ff41;
        }
        
        .grid-lines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 255, 65, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 65, 0.05) 1px, transparent 1px);
            background-size: 50px 50px;
            pointer-events: none;
        }
        
        .central-symbol {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 120px;
            color: #00ff41;
            opacity: 0.08;
            text-shadow: 0 0 30px #00ff41;
            animation: central-pulse 6s ease-in-out infinite;
        }
        
        @keyframes central-pulse {
            0%, 100% { opacity: 0.05; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.12; transform: translate(-50%, -50%) scale(1.02); }
        }
        
        .status-bar {
            position: fixed !important;
            bottom: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 28px;
            background: linear-gradient(180deg, #2a2a2a, #1a1a1a);
            border-top: 2px inset #555;
            display: flex !important;
            align-items: center;
            padding: 0 10px;
            font-size: 11px;
            color: #ccc;
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.1);
            z-index: 1000 !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
        
        .location-info {
            display: flex;
            align-items: center;
            gap: 15px;
            font-size: 10px;
        }
        
        .info-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .moon-phase {
            font-size: 12px;
        }
        
        .status-item {
            margin-right: 15px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .status-led {
            width: 8px;
            height: 8px;
            background: #00ff41;
            border-radius: 50%;
            box-shadow: 0 0 4px #00ff41;
            animation: led-blink 2s infinite;
        }
        
        @keyframes led-blink {
            0%, 90% { opacity: 1; }
            95% { opacity: 0.3; }
        }
        
        .desktop-icon {
            position: absolute;
            width: 64px;
            text-align: center;
            cursor: pointer;
            user-select: none;
        }
        
        .desktop-icon:hover .icon-image {
            background: rgba(0, 0, 139, 0.3);
        }
        
        .icon-image {
            width: 32px;
            height: 32px;
            background: #c0c0c0;
            border: 1px outset #c0c0c0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            margin: 0 auto 4px;
            box-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .icon-label {
            color: white;
            font-size: 11px;
            text-shadow: 1px 1px 1px #000;
            line-height: 1.2;
            font-family: 'MS Sans Serif', sans-serif;
        }
        
        .sapphire-skull-icon {
            background: linear-gradient(135deg, #4c1d95 0%, #7c3aed 30%, #a855f7 60%, #4c1d95 100%) !important;
            border: 1px outset #4c1d95 !important;
            color: #ffffff !important;
            text-shadow: 0 0 8px #7c3aed;
            box-shadow: 0 0 12px rgba(124, 58, 237, 0.4);
        }
        
        .red-diamond-icon {
            background: linear-gradient(135deg, #cc3333 0%, #ff6666 50%, #cc3333 100%) !important;
            border: 1px outset #cc3333 !important;
            color: white !important;
        }
        
        .store-icon {
            background: linear-gradient(135deg, #4a90e2 0%, #c0c0c0 50%, #4a90e2 100%) !important;
            border: 1px outset #4a90e2 !important;
        }
        
        .window-demo {
            position: absolute;
            top: 15%;
            left: 45%;
            width: 300px;
            height: 200px;
            background: #c0c0c0;
            border: 2px outset #c0c0c0;
            box-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            font-family: 'MS Sans Serif', sans-serif;
            font-size: 11px;
            opacity: 0.7;
        }
        
        .window-title {
            height: 20px;
            background: linear-gradient(90deg, #000080, #0000ff);
            color: white;
            display: flex;
            align-items: center;
            padding: 0 5px;
            font-weight: bold;
        }
        
        .window-content {
            padding: 10px;
            background: #c0c0c0;
            height: calc(100% - 20px);
            color: #000;
            font-family: 'Share Tech Mono', monospace;
            font-size: 9px;
            line-height: 1.3;
        }
        
        .glitch-text {
            color: #00ff41;
            animation: glitch 4s infinite;
        }
        
        @keyframes glitch {
            0%, 98% { color: #00ff41; }
            99% { color: #ff0041; }
        }

        /* GAME WINDOW STYLES */
        .game-window {
            display: none;
            position: absolute;
            top: 5%;
            left: 5%;
            width: 90%;
            height: 85%;
            background: #c0c0c0;
            border: 2px outset #c0c0c0;
            box-shadow: 4px 4px 8px rgba(0,0,0,0.5);
            font-family: 'MS Sans Serif', sans-serif;
            z-index: 999;
            min-width: 800px;
            min-height: 600px;
        }

        .game-window-title {
            height: 24px;
            background: linear-gradient(90deg, #000080, #0000ff);
            color: white;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 8px;
            font-weight: bold;
            font-size: 11px;
            cursor: move;
        }

        .window-controls {
            display: flex;
            gap: 2px;
        }

        .window-button {
            width: 16px;
            height: 14px;
            background: #c0c0c0;
            border: 1px outset #c0c0c0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            font-weight: bold;
            cursor: pointer;
            color: #000;
        }

        .window-button:hover {
            background: #e0e0e0;
        }

        .window-button:active {
            border: 1px inset #c0c0c0;
        }

        /* GAME CONTENT STYLES */
        .game-content {
            width: 100%;
            height: calc(100% - 24px);
            background: linear-gradient(135deg, #2d1810 0%, #4a3625 100%);
            color: #f4e8d0;
            font-family: 'Georgia', serif;
            overflow: auto;
            position: relative;
        }

        .game-content .container {
            max-width: 100%;
            margin: 0;
            padding: 10px;
        }

        .game-content h1 {
            text-align: center;
            color: #d4af37;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 10px;
            font-size: 18px;
        }

        .game-content .subtitle {
            text-align: center;
            font-style: italic;
            margin-bottom: 20px;
            color: #c9a876;
            font-size: 12px;
        }

        .game-content .controls {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            border: 2px solid #d4af37;
        }

        .game-content .control-group {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .game-content .control-group label {
            font-size: 10px;
            color: #d4af37;
            font-weight: bold;
        }

        .game-content button {
            background: linear-gradient(135deg, #d4af37, #b8941f);
            color: #2d1810;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 10px;
            transition: all 0.3s ease;
        }

        .game-content button:hover {
            background: linear-gradient(135deg, #e6c552, #d4af37);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .game-content select, .game-content input {
            background: rgba(0,0,0,0.4);
            color: #f4e8d0;
            border: 1px solid #d4af37;
            padding: 6px;
            border-radius: 3px;
            font-size: 10px;
        }

        .game-content .game-area {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .game-content .canvas-container {
            position: relative;
            border: 3px solid #d4af37;
            border-radius: 10px;
            background: #1a1a1a;
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.3);
            flex: 1;
            min-width: 400px;
        }

        .game-content #gameCanvas {
            display: block;
            cursor: crosshair;
        }

        .game-content .side-panel {
            width: 280px;
            background: rgba(0,0,0,0.4);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #d4af37;
            height: fit-content;
            min-width: 280px;
        }

        .game-content .info-section {
            margin-bottom: 15px;
            padding: 12px;
            background: rgba(212, 175, 55, 0.1);
            border-radius: 8px;
            border-left: 4px solid #d4af37;
        }

        .game-content .info-section h3 {
            margin: 0 0 8px 0;
            color: #d4af37;
            font-size: 12px;
        }

        .game-content .coordinate-display {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(0,0,0,0.7);
            color: #d4af37;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 10px;
            font-family: monospace;
        }

        .game-content .energy-display {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 8px;
        }

        .game-content .energy-meter {
            background: rgba(0,0,0,0.3);
            padding: 6px;
            border-radius: 5px;
            text-align: center;
            font-size: 10px;
        }

        .game-content .energy-bar {
            width: 100%;
            height: 4px;
            background: rgba(0,0,0,0.3);
            border-radius: 3px;
            margin-top: 3px;
            overflow: hidden;
        }

        .game-content .energy-fill {
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 3px;
        }

        .game-content .sacred-meter .energy-fill { background: linear-gradient(90deg, #ff6b35, #f7931e); }
        .game-content .harmony-meter .energy-fill { background: linear-gradient(90deg, #4ecdc4, #44a08d); }
        .game-content .prosperity-meter .energy-fill { background: linear-gradient(90deg, #d4af37, #ffdb4d); }
        .game-content .protection-meter .energy-fill { background: linear-gradient(90deg, #667eea, #764ba2); }

        .game-content .legend {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 8px;
            margin-top: 10px;
        }

        .game-content .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 9px;
        }

        .game-content .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .game-content .status-text {
            font-size: 9px;
            line-height: 1.3;
            color: #c9a876;
        }

        /* Prompt Modal Styles */
        .prompt-modal {
            display: none;
            position: absolute;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            backdrop-filter: blur(5px);
        }

        .prompt-modal-content {
            background: linear-gradient(135deg, #2d1810 0%, #4a3625 100%);
            margin: 10% auto;
            padding: 20px;
            border: 3px solid #d4af37;
            border-radius: 15px;
            width: 80%;
            max-width: 600px;
            max-height: 70%;
            overflow-y: auto;
            color: #f4e8d0;
            box-shadow: 0 0 30px rgba(212, 175, 55, 0.5);
            position: relative;
        }

        .prompt-modal h2 {
            color: #d4af37;
            text-align: center;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            font-size: 16px;
        }

        .prompt-textarea {
            width: 100%;
            height: 200px;
            background: rgba(0,0,0,0.4);
            color: #f4e8d0;
            border: 2px solid #d4af37;
            border-radius: 8px;
            padding: 10px;
            font-family: 'Georgia', serif;
            font-size: 11px;
            line-height: 1.4;
            resize: vertical;
            margin-bottom: 15px;
        }

        .prompt-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .close-btn {
            background: linear-gradient(135deg, #8b0000, #a00000) !important;
            color: white !important;
        }

        .close-btn:hover {
            background: linear-gradient(135deg, #a00000, #c00000) !important;
        }

        .copy-btn {
            background: linear-gradient(135deg, #006400, #228b22) !important;
            color: white !important;
        }

        .copy-btn:hover {
            background: linear-gradient(135deg, #228b22, #32cd32) !important;
        }

        /* Animation for window opening */
        .game-window.opening {
            animation: window-open 0.3s ease-out;
        }

        @keyframes window-open {
            from {
                transform: scale(0.8);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* Responsive adjustments */
        @media (max-width: 1200px) {
            .game-window {
                width: 95%;
                height: 90%;
                top: 2.5%;
                left: 2.5%;
            }
            
            .game-content .game-area {
                flex-direction: column;
            }
            
            .game-content .canvas-container {
                min-width: 300px;
            }
            
            .game-content .side-panel {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="desktop">
        <div class="gator-backdrop"></div>
        <div class="grid-lines"></div>
        <div class="scan-lines"></div>
        
        <div class="glyph-overlay" id="runic-field">
        </div>
        
        <div class="central-symbol">◊</div>
        
        <div class="terminal-corners corner-tl">┌──</div>
        <div class="terminal-corners corner-tr">──┐</div>
        <div class="terminal-corners corner-bl">└──</div>
        <div class="terminal-corners corner-br">──┘</div>
        
        <div class="data-stream">
            <div class="glitch-text">NEURAL.NET.ACCESS</div>
            <div>CPU: 486DX/66MHz</div>
            <div>RAM: 8MB</div>
            <div>CONNECT: 14.4k</div>
            <div>STATUS: <span style="color: #00ff41;">ONLINE</span></div>
            <div style="margin-top: 10px; opacity: 0.4;">
                01001000 01000001<br>
                01000011 01001011<br>
                01000101 01010010
            </div>
        </div>
        
        <div class="desktop-icon" style="top: 80px; left: 80px;" onclick="GatorGame.launch()">
            <div class="icon-image">🐊</div>
            <div class="icon-label">gatortopia.exe</div>
        </div>
        
        <a href="https://www.instagram.com/glowgator/" target="_blank" class="desktop-icon" style="top: 160px; left: 80px; text-decoration: none;">
            <div class="icon-image">📷</div>
            <div class="icon-label">photos</div>
        </a>
        
        <a href="https://www.youtube.com/@glowg8r" target="_blank" class="desktop-icon" style="top: 240px; left: 80px; text-decoration: none;">
            <div class="icon-image">📹</div>
            <div class="icon-label">videos</div>
        </a>
        
        <a href="https://soundcloud.com/glowg8r" target="_blank" class="desktop-icon" style="top: 320px; left: 80px; text-decoration: none;">
            <div class="icon-image">🎵</div>
            <div class="icon-label">music</div>
        </a>
        
        <a href="https://medium.com/@glowg8r" target="_blank" class="desktop-icon" style="top: 400px; left: 80px; text-decoration: none;">
            <div class="icon-image">📒</div>
            <div class="icon-label">my vault</div>
        </a>
        
        <a href="https://glowgator.gumroad.com" target="_blank" class="desktop-icon" style="top: 480px; left: 80px; text-decoration: none;">
            <div class="icon-image store-icon">🛍️</div>
            <div class="icon-label">my store</div>
        </a>
        
        <a href="https://jemstudios.drr.ac/" target="_blank" class="desktop-icon" style="bottom: 80px; left: 80px; text-decoration: none;">
            <div class="icon-image sapphire-skull-icon">💎</div>
            <div class="icon-label">jem studios</div>
        </a>
        
        <a href="https://cinnabar.drr.ac" target="_blank" class="desktop-icon" style="bottom: 80px; right: 80px; text-decoration: none;">
            <div class="icon-image red-diamond-icon">♦️</div>
            <div class="icon-label">cinnabar</div>
        </a>
        
        <div class="window-demo">
            <div class="window-title">SYSTEM.EXE - Neural Interface</div>
            <div class="window-content">
                > INITIATE GATOR SYNTHESIS PROTOCOL<br>
                > SCANNING SWAMP BIOMETRICS...<br>
                > SCALE ARMOR: <span class="glitch-text">ACTIVE</span><br>
                > JAW HYDRAULICS: CHARGING<br>
                <br>
                <span style="color: #00ff41;">[ APEX PREDATOR MODE ]</span>
            </div>
        </div>
        
        <!-- GATORTOPIA GAME WINDOW -->
        <div id="gatortopia-window" class="game-window">
            <div class="game-window-title">
                <span>🐊 GATORTOPIA.EXE - Geomantic Cathedral City Simulator v1.44.9</span>
                <div class="window-controls">
                    <div class="window-button" onclick="GatorGame.close()">✖</div>
                </div>
            </div>
            <div class="game-content">
                <div class="container">
                    <h1>🐊 Geomantic Cathedral City Simulator 🐊</h1>
                    <p class="subtitle">Build sacred cities following ancient hermetic principles</p>
                    
                    <div class="controls">
                        <div class="control-group">
                            <label>Building Type</label>
                            <select id="buildingType">
                                <option value="cathedral">⛪ Cathedral (Sacred Nexus)</option>
                                <option value="house">🏠 House</option>
                                <option value="cottage">🏡 Cottage</option>
                                <option value="manor">🏘️ Manor</option>
                                <option value="villa">🏛️ Villa</option>
                                <option value="apartment">🏢 Apartments</option>
                                <option value="market">🏪 Market</option>
                                <option value="temple">🕌 Temple</option>
                                <option value="workshop">🔨 Workshop</option>
                                <option value="garden">🌳 Sacred Garden</option>
                                <option value="gator_garden">🐊 Gator Garden</option>
                                <option value="well">🌊 Sacred Well</option>
                                <option value="fountain">⛲ Fountain</option>
                                <option value="pond">🏞️ Sacred Pond</option>
                                <option value="spring">💧 Natural Spring</option>
                                <option value="waterway">🌀 Waterway</option>
                                <option value="tower">🗼 Watchtower</option>
                                <option value="wall">🧱 Defensive Wall</option>
                                <option value="gate">🚪 City Gate</option>
                                <option value="barracks">⚔️ Barracks</option>
                                <option value="fortress">🏰 Fortress</option>
                                <option value="crystal_mine">💎 Crystal Mine</option>
                                <option value="crystal_forge">🔮 Crystal Forge</option>
                                <option value="copper_mine">🟫 Copper Mine</option>
                                <option value="copper_forge">🔨 Copper Forge</option>
                                <option value="library">📚 Sacred Library</option>
                                <option value="monastery">🏛️ Monastery</option>
                                <option value="sanctuary">🔮 Crystal Sanctuary</option>
                                <option value="plaza">🌟 Sacred Plaza</option>
                            </select>
                        </div>
                        
                        <div class="control-group">
                            <label>Grid Mode</label>
                            <select id="gridMode" onchange="GatorGame.handleGridChange()">
                                <option value="sacred">Sacred Geometry</option>
                                <option value="cross">Cross Pattern</option>
                                <option value="labyrinth">Labyrinth</option>
                                <option value="hexagon">Hexagonal Grid</option>
                                <option value="spiral">Golden Spiral</option>
                                <option value="mandala">Mandala Pattern</option>
                                <option value="tree">Tree of Life</option>
                                <option value="spider_web">Spider Web</option>
                                <option value="nordic_circles">Nordic Circles</option>
                                <option value="free">Free Placement</option>
                            </select>
                        </div>
                        
                        <button onclick="GatorGame.clearCity()">🗑️ Clear City</button>
                        <button onclick="GatorGame.toggleEnergyFlow()">⚡ Toggle Energy Flow</button>
                        <button onclick="GatorGame.generateCity()">🎲 Generate Sacred City</button>
                        <button onclick="GatorGame.generatePrompt()">🎨 Generate Image Prompt</button>
                        <button onclick="GatorGame.close()">🚪 Exit to Desktop</button>
                    </div>

                    <div class="game-area">
                        <div class="canvas-container">
                            <canvas id="gameCanvas" width="800" height="600"></canvas>
                            <div class="coordinate-display" id="coordinates">Position: (0, 0)</div>
                        </div>
                        
                        <div class="side-panel">
                            <div class="info-section">
                                <h3>🗝️ Building Legend</h3>
                                <div class="legend">
                                    <div class="legend-item">
                                        <div class="legend-color" style="background: #d4af37;"></div>
                                        Cathedral
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-color" style="background: #8b4513;"></div>
                                        House
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-color" style="background: #daa520;"></div>
                                        Cottage
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-color" style="background: #a0522d;"></div>
                                        Manor
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-color" style="background: #cd853f;"></div>
                                        Villa
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-color" style="background: #696969;"></div>
                                        Apartments
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-color" style="background: #ff6b35;"></div>
                                        Market
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-color" style="background: #4ecdc4;"></div>
                                        Temple
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-color" style="background: #666;"></div>
                                        Workshop
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-color" style="background: #228b22;"></div>
                                        Garden
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-color" style="background: #006400;"></div>
                                        Gator Garden
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-color" style="background: #1e90ff;"></div>
                                        Well
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-color" style="background: #00ced1;"></div>
                                        Fountain
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-color" style="background: #20b2aa;"></div>
                                        Pond
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-color" style="background: #48cae4;"></div>
                                        Spring
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-color" style="background: #0077be;"></div>
                                        Waterway
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-color" style="background: #8a2be2;"></div>
                                        Tower
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-color" style="background: #708090;"></div>
                                        Wall
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-color" style="background: #556b2f;"></div>
                                        Gate
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-color" style="background: #8b0000;"></div>
                                        Barracks
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-color" style="background: #2f4f4f;"></div>
                                        Fortress
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-color" style="background: #9370db;"></div>
                                        Crystal Mine
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-color" style="background: #ba55d3;"></div>
                                        Crystal Forge
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-color" style="background: #b87333;"></div>
                                        Copper Mine
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-color" style="background: #d2691e;"></div>
                                        Copper Forge
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-color" style="background: #4b0082;"></div>
                                        Library
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-color" style="background: #800080;"></div>
                                        Monastery
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-color" style="background: #ff1493;"></div>
                                        Sanctuary
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-color" style="background: #ffd700;"></div>
                                        Plaza
                                    </div>
                                </div>
                            </div>

                            <div class="info-section">
                                <h3>🌟 City Energies</h3>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 8px;">
                                    <div class="energy-meter sacred-meter">
                                        Sacred Power
                                        <div class="energy-bar">
                                            <div class="energy-fill" id="sacredEnergy" style="width: 0%"></div>
                                        </div>
                                    </div>
                                    <div class="energy-meter harmony-meter">
                                        Harmony
                                        <div class="energy-bar">
                                            <div class="energy-fill" id="harmonyEnergy" style="width: 0%"></div>
                                        </div>
                                    </div>
                                    <div class="energy-meter prosperity-meter">
                                        Prosperity
                                        <div class="energy-bar">
                                            <div class="energy-fill" id="prosperityEnergy" style="width: 0%"></div>
                                        </div>
                                    </div>
                                    <div class="energy-meter protection-meter">
                                        Protection
                                        <div class="energy-bar">
                                            <div class="energy-fill" id="protectionEnergy" style="width: 0%"></div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="info-section">
                                <h3>📜 Geomantic Principles</h3>
                                <p style="font-size: 9px; line-height: 1.3; color: #00ff65;" id="principleText">
                                    Place the Cathedral at the center of your city as the sacred nexus. All energy flows from this heart of spiritual and temporal power.
                                </p>
                            </div>

                            <div class="info-section">
                                <h3>📊 City Status</h3>
                                <p style="font-size: 9px; line-height: 1.3; color: #00ff65;" id="statusText">
                                    Population: 0<br>
                                    Buildings: 0<br>
                                    Cathedrals: 0<br>
                                    Energy Centers: 0
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Prompt Generation Modal -->
        <div id="promptModal" class="prompt-modal">
            <div class="prompt-modal-content">
                <h2>🎨 Generated Image Prompt</h2>
                <textarea id="promptText" class="prompt-textarea" readonly placeholder="Your generated prompt will appear here..."></textarea>
                <div class="prompt-buttons">
                    <button onclick="GatorGame.copyPrompt()" class="copy-btn">📋 Copy Prompt</button>
                    <button onclick="GatorGame.regeneratePrompt()">🔄 Regenerate</button>
                    <button onclick="GatorGame.closePromptModal()" class="close-btn">✖️ Close</button>
                </div>
            </div>
        </div>
        
        <div class="status-bar">
            <div class="location-info">
                <div class="info-item">
                    <span>🕐</span>
                    <span id="current-time">Loading...</span>
                </div>
                <div class="info-item">
                    <span id="moon-emoji" class="moon-phase">🌘</span>
                    <span id="moon-phase">Loading...</span>
                </div>
            </div>
            <div style="margin-left: 40px;" class="status-item">
                <div class="status-led"></div>
                NEURAL LINK
            </div>
            <div class="status-item">SYS.CORE.ACCESS</div>
            <div style="margin-left: auto;">GATOR OS v1.44.9</div>
        </div>
    </div>

    <!-- IMMEDIATE INLINE SCRIPT FOR TASKBAR -->
    <script>
        console.log('🚀 Immediate script starting...');
        
        // Immediate time update function
        function updateTimeNow() {
            try {
                const now = new Date();
                const timeStr = now.toLocaleTimeString('en-US', { 
                    hour: 'numeric', 
                    minute: '2-digit',
                    hour12: true 
                });
                const timeEl = document.getElementById('current-time');
                if (timeEl) {
                    timeEl.textContent = timeStr;
                    console.log('✅ Time updated:', timeStr);
                } else {
                    console.error('❌ Time element not found');
                }
            } catch (error) {
                console.error('❌ Error updating time:', error);
            }
        }
        
        // Immediate moon phase function
        function updateMoonNow() {
            try {
                const today = new Date();
                const year = today.getFullYear();
                const month = today.getMonth() + 1;
                const day = today.getDate();
                
                const c = Math.floor((year - 1900) / 100);
                const e = 2 * (year - 1900 - 100 * c);
                const jd = 365.25 * (year - 1900) + 30.6 * month + day - 0.75 * c + 1;
                const b = (jd - 2451550.1) / 29.530588853;
                const phase = (b - Math.floor(b)) * 29.530588853;
                
                let moonData;
                if (phase < 1.84566) moonData = { emoji: '🌑', name: 'New Moon' };
                else if (phase < 5.53699) moonData = { emoji: '🌒', name: 'Waxing Crescent' };
                else if (phase < 9.22831) moonData = { emoji: '🌓', name: 'First Quarter' };
                else if (phase < 12.91963) moonData = { emoji: '🌔', name: 'Waxing Gibbous' };
                else if (phase < 16.61096) moonData = { emoji: '🌕', name: 'Full Moon' };
                else if (phase < 20.30228) moonData = { emoji: '🌖', name: 'Waning Gibbous' };
                else if (phase < 23.99361) moonData = { emoji: '🌗', name: 'Last Quarter' };
                else if (phase < 27.68493) moonData = { emoji: '🌘', name: 'Waning Crescent' };
                else moonData = { emoji: '🌑', name: 'New Moon' };
                
                const moonEmoji = document.getElementById('moon-emoji');
                const moonPhaseEl = document.getElementById('moon-phase');
                
                if (moonEmoji) {
                    moonEmoji.textContent = moonData.emoji;
                    console.log('✅ Moon emoji updated:', moonData.emoji);
                } else {
                    console.error('❌ Moon emoji element not found');
                }
                
                if (moonPhaseEl) {
                    moonPhaseEl.textContent = moonData.name;
                    console.log('✅ Moon phase updated:', moonData.name);
                } else {
                    console.error('❌ Moon phase element not found');
                }
            } catch (error) {
                console.error('❌ Error updating moon:', error);
            }
        }
        
        // Run immediately
        console.log('🔥 Running immediate updates...');
        updateTimeNow();
        updateMoonNow();
        
        // Set up timer
        setInterval(updateTimeNow, 1000);
        
        // Immediate rune animation function
        function startRunesNow() {
            try {
                const runes = ['ᚠ', 'ᚢ', 'ᛉ', 'ᛟ'];
                const runicField = document.getElementById('runic-field');
                if (!runicField) {
                    console.warn('❌ Runic field not found');
                    return;
                }
                console.log('✨ Starting rune animations...');
                
                function spawnRune() {
                    try {
                        const rune = document.createElement('div');
                        rune.className = 'hypnotic-rune';
                        rune.textContent = runes[Math.floor(Math.random() * runes.length)];
                        
                        const x = Math.random() * 60 + 20;
                        const y = Math.random() * 60 + 20;
                        
                        rune.style.position = 'absolute';
                        rune.style.left = x + '%';
                        rune.style.top = y + '%';
                        rune.style.color = '#00ff41';
                        rune.style.fontSize = '28px';
                        rune.style.fontWeight = 'bold';
                        rune.style.textShadow = '0 0 15px #00ff41, 0 0 25px #00ff41';
                        rune.style.pointerEvents = 'none';
                        rune.style.zIndex = '1';
                        
                        const duration = Math.random() * 2000 + 3000;
                        rune.style.animation = `rune-appear ${duration}ms ease-in-out`;
                        
                        runicField.appendChild(rune);
                        
                        setTimeout(() => {
                            if (rune.parentNode) {
                                rune.parentNode.removeChild(rune);
                            }
                        }, duration);
                    } catch (error) {
                        console.warn('Error spawning rune:', error);
                    }
                }
                
                // Start spawning runes
                const rhythms = [3200, 4700, 2900, 5100, 3800, 4200];
                rhythms.forEach((interval, index) => {
                    setTimeout(() => {
                        spawnRune();
                        setInterval(spawnRune, interval);
                    }, index * 800);
                });
                
                console.log('✅ Rune animations started');
            } catch (error) {
                console.error('❌ Error starting runes:', error);
            }
        }
        
        // Start runes after a short delay
        setTimeout(startRunesNow, 500);
        
        console.log('✅ Immediate script completed');
    </script>

    <script>
        // =================================================================
        // DESKTOP ENVIRONMENT SCRIPTS - MOVED TO TOP FOR RELIABILITY
        // =================================================================

        function updateTime() {
            try {
                const now = new Date();
                const timeStr = now.toLocaleTimeString('en-US', { 
                    hour: 'numeric', 
                    minute: '2-digit',
                    hour12: true 
                });
                const timeEl = document.getElementById('current-time');
                if (timeEl) {
                    timeEl.textContent = timeStr;
                }
            } catch (error) {
                console.error('Error updating time:', error);
            }
        }

        function getMoonPhase() {
            try {
                const today = new Date();
                const year = today.getFullYear();
                const month = today.getMonth() + 1;
                const day = today.getDate();

                const c = Math.floor((year - 1900) / 100);
                const e = 2 * (year - 1900 - 100 * c);
                const jd = 365.25 * (year - 1900) + 30.6 * month + day - 0.75 * c + 1;
                const b = (jd - 2451550.1) / 29.530588853;
                const phase = (b - Math.floor(b)) * 29.530588853;

                if (phase < 1.84566) return { emoji: '🌑', name: 'New Moon' };
                else if (phase < 5.53699) return { emoji: '🌒', name: 'Waxing Crescent' };
                else if (phase < 9.22831) return { emoji: '🌓', name: 'First Quarter' };
                else if (phase < 12.91963) return { emoji: '🌔', name: 'Waxing Gibbous' };
                else if (phase < 16.61096) return { emoji: '🌕', name: 'Full Moon' };
                else if (phase < 20.30228) return { emoji: '🌖', name: 'Waning Gibbous' };
                else if (phase < 23.99361) return { emoji: '🌗', name: 'Last Quarter' };
                else if (phase < 27.68493) return { emoji: '🌘', name: 'Waning Crescent' };
                else return { emoji: '🌑', name: 'New Moon' };
            } catch (error) {
                console.error('Error calculating moon phase:', error);
                return { emoji: '🌑', name: 'New Moon' };
            }
        }

        function createHypnoticRunes() {
            try {
                const runes = ['ᚠ', 'ᚢ', 'ᛉ', 'ᛟ'];
                const runicField = document.getElementById('runic-field');
                if (!runicField) {
                    console.warn('Runic field element not found');
                    return;
                }
                
                const rhythms = [3200, 4700, 2900, 5100, 3800, 4200];

                function spawnRune() {
                    try {
                        const rune = document.createElement('div');
                        rune.className = 'hypnotic-rune';
                        rune.textContent = runes[Math.floor(Math.random() * runes.length)];

                        const x = Math.random() * 60 + 20;
                        const y = Math.random() * 60 + 20;

                        rune.style.left = x + '%';
                        rune.style.top = y + '%';

                        const duration = Math.random() * 2000 + 3000;
                        rune.style.animationDuration = duration + 'ms';

                        runicField.appendChild(rune);

                        setTimeout(() => {
                            if (rune.parentNode) {
                                rune.parentNode.removeChild(rune);
                            }
                        }, duration);
                    } catch (error) {
                        console.warn('Error spawning rune:', error);
                    }
                }

                rhythms.forEach((interval, index) => {
                    setTimeout(() => {
                        spawnRune();
                        setInterval(spawnRune, interval);
                    }, index * 800);
                });
            } catch (error) {
                console.error('Error creating hypnotic runes:', error);
            }
        }

        // =================================================================
        // OPTIMIZED GATORTOPIA GAME ENGINE
        // =================================================================

        const GatorGame = {
            // Core game state
            canvas: null,
            ctx: null,
            isInitialized: false,
            animationId: null,
            buildings: [],
            energyFlows: [],
            showEnergyFlowMode: false,
            
            // Performance optimization
            lastRenderTime: 0,
            targetFPS: 30,
            frameInterval: 1000 / 30,
            needsRedraw: true,

            // Building type definitions - optimized and organized
            buildingTypes: {
                cathedral: { 
                    color: '#d4af37', size: 40, 
                    energy: { sacred: 50, harmony: 30, prosperity: 20, protection: 40 },
                    population: 0, emoji: '⛪', cost: 1000
                },
                house: { 
                    color: '#8b4513', size: 20, 
                    energy: { sacred: 5, harmony: 10, prosperity: 5, protection: 5 },
                    population: 4, emoji: '🏠', cost: 100
                },
                cottage: { 
                    color: '#daa520', size: 18, 
                    energy: { sacred: 8, harmony: 15, prosperity: 3, protection: 3 },
                    population: 2, emoji: '🏡', cost: 80
                },
                manor: { 
                    color: '#a0522d', size: 30, 
                    energy: { sacred: 10, harmony: 8, prosperity: 15, protection: 8 },
                    population: 8, emoji: '🏘️', cost: 300
                },
                villa: { 
                    color: '#cd853f', size: 28, 
                    energy: { sacred: 15, harmony: 12, prosperity: 20, protection: 10 },
                    population: 6, emoji: '🏛️', cost: 250
                },
                apartment: { 
                    color: '#696969', size: 25, 
                    energy: { sacred: 3, harmony: 5, prosperity: 8, protection: 12 },
                    population: 12, emoji: '🏢', cost: 200
                },
                market: { 
                    color: '#ff6b35', size: 25, 
                    energy: { sacred: 0, harmony: 5, prosperity: 25, protection: 5 },
                    population: 0, emoji: '🏪', cost: 300
                },
                temple: { 
                    color: '#4ecdc4', size: 30, 
                    energy: { sacred: 30, harmony: 25, prosperity: 10, protection: 20 },
                    population: 0, emoji: '🕌', cost: 500
                },
                workshop: { 
                    color: '#666', size: 25, 
                    energy: { sacred: 0, harmony: 5, prosperity: 15, protection: 10 },
                    population: 2, emoji: '🔨', cost: 200
                },
                garden: { 
                    color: '#228b22', size: 20, 
                    energy: { sacred: 10, harmony: 20, prosperity: 5, protection: 5 },
                    population: 0, emoji: '🌳', cost: 150
                },
                gator_garden: { 
                    color: '#006400', size: 50, 
                    energy: { sacred: 25, harmony: 35, prosperity: 15, protection: 20 },
                    population: 0, emoji: '🐊', cost: 800, isGatorGarden: true
                },
                well: { 
                    color: '#1e90ff', size: 15, 
                    energy: { sacred: 15, harmony: 15, prosperity: 10, protection: 10 },
                    population: 0, emoji: '🌊', cost: 250, isWater: true
                },
                fountain: { 
                    color: '#00ced1', size: 20, 
                    energy: { sacred: 10, harmony: 25, prosperity: 15, protection: 8 },
                    population: 0, emoji: '⛲', cost: 350, isWater: true
                },
                pond: { 
                    color: '#20b2aa', size: 30, 
                    energy: { sacred: 20, harmony: 30, prosperity: 10, protection: 15 },
                    population: 0, emoji: '🏞️', cost: 400, isWater: true
                },
                spring: { 
                    color: '#48cae4', size: 18, 
                    energy: { sacred: 25, harmony: 20, prosperity: 8, protection: 12 },
                    population: 0, emoji: '💧', cost: 300, isWater: true
                },
                waterway: { 
                    color: '#0077be', size: 35, 
                    energy: { sacred: 15, harmony: 35, prosperity: 20, protection: 15 },
                    population: 0, emoji: '🌀', cost: 500, isWater: true
                },
                tower: { 
                    color: '#8a2be2', size: 25, 
                    energy: { sacred: 5, harmony: 5, prosperity: 5, protection: 30 },
                    population: 1, emoji: '🗼', cost: 400
                },
                wall: { 
                    color: '#708090', size: 15, 
                    energy: { sacred: 0, harmony: 2, prosperity: 0, protection: 25 },
                    population: 0, emoji: '🧱', cost: 150, isDefense: true
                },
                gate: { 
                    color: '#556b2f', size: 20, 
                    energy: { sacred: 5, harmony: 8, prosperity: 10, protection: 20 },
                    population: 2, emoji: '🚪', cost: 300, isDefense: true
                },
                barracks: { 
                    color: '#8b0000', size: 28, 
                    energy: { sacred: 0, harmony: 5, prosperity: 5, protection: 35 },
                    population: 8, emoji: '⚔️', cost: 500, isDefense: true
                },
                fortress: { 
                    color: '#2f4f4f', size: 35, 
                    energy: { sacred: 10, harmony: 5, prosperity: 0, protection: 50 },
                    population: 4, emoji: '🏰', cost: 800, isDefense: true
                },
                crystal_mine: { 
                    color: '#9370db', size: 22, 
                    energy: { sacred: 30, harmony: 15, prosperity: 20, protection: 10 },
                    population: 3, emoji: '💎', cost: 600, isCrystal: true
                },
                crystal_forge: { 
                    color: '#ba55d3', size: 26, 
                    energy: { sacred: 40, harmony: 25, prosperity: 15, protection: 15 },
                    population: 4, emoji: '🔮', cost: 750, isCrystal: true
                },
                copper_mine: { 
                    color: '#b87333', size: 20, 
                    energy: { sacred: 5, harmony: 10, prosperity: 25, protection: 5 },
                    population: 4, emoji: '🟫', cost: 400, isCopper: true
                },
                copper_forge: { 
                    color: '#d2691e', size: 24, 
                    energy: { sacred: 8, harmony: 12, prosperity: 30, protection: 8 },
                    population: 5, emoji: '🔨', cost: 500, isCopper: true
                },
                library: { 
                    color: '#4b0082', size: 35, 
                    energy: { sacred: 35, harmony: 20, prosperity: 15, protection: 15 },
                    population: 3, emoji: '📚', cost: 600
                },
                monastery: { 
                    color: '#800080', size: 30, 
                    energy: { sacred: 40, harmony: 35, prosperity: 5, protection: 25 },
                    population: 6, emoji: '🏛️', cost: 750
                },
                sanctuary: { 
                    color: '#ff1493', size: 25, 
                    energy: { sacred: 45, harmony: 30, prosperity: 10, protection: 20 },
                    population: 2, emoji: '🔮', cost: 800
                },
                plaza: { 
                    color: '#ffd700', size: 40, 
                    energy: { sacred: 20, harmony: 40, prosperity: 30, protection: 15 },
                    population: 0, emoji: '🌟', cost: 500
                }
            },

            // =================================================================
            // CORE INITIALIZATION
            // =================================================================

            launch() {
                console.log('Launching Gatortopia...');
                const gameWindow = document.getElementById('gatortopia-window');
                gameWindow.style.display = 'block';
                gameWindow.classList.add('opening');
                
                setTimeout(() => {
                    this.initialize();
                }, 300);
            },

            close() {
                console.log('Closing Gatortopia...');
                const gameWindow = document.getElementById('gatortopia-window');
                gameWindow.style.display = 'none';
                gameWindow.classList.remove('opening');
                
                this.cleanup();
            },

            initialize() {
                try {
                    // Get canvas and context
                    this.canvas = document.getElementById('gameCanvas');
                    if (!this.canvas) {
                        throw new Error('Canvas not found');
                    }

                    this.ctx = this.canvas.getContext('2d');
                    if (!this.ctx) {
                        throw new Error('Cannot get 2D context');
                    }

                    // Reset state
                    this.buildings = [];
                    this.energyFlows = [];
                    this.showEnergyFlowMode = false;
                    this.needsRedraw = true;

                    // Set up event listeners
                    this.setupEventListeners();

                    // Mark as initialized
                    this.isInitialized = true;

                    // Initial render and UI update
                    this.render();
                    this.updateUI();

                    // Start animation loop
                    this.startAnimation();

                    console.log('Gatortopia initialized successfully');
                    return true;
                } catch (error) {
                    console.error('Failed to initialize Gatortopia:', error);
                    alert('Failed to initialize game: ' + error.message);
                    return false;
                }
            },

            cleanup() {
                this.isInitialized = false;
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
                this.buildings = [];
                this.energyFlows = [];
            },

            // =================================================================
            // EVENT HANDLING - OPTIMIZED
            // =================================================================

            setupEventListeners() {
                // Canvas click handler
                this.canvas.addEventListener('click', (event) => {
                    this.handleCanvasClick(event);
                });

                // Mouse move handler for coordinates
                this.canvas.addEventListener('mousemove', (event) => {
                    this.handleMouseMove(event);
                });

                // Modal handlers
                this.setupModalHandlers();
            },

            handleCanvasClick(event) {
                if (!this.isInitialized) return;

                try {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = Math.round(event.clientX - rect.left);
                    const y = Math.round(event.clientY - rect.top);

                    if (x < 0 || y < 0 || x >= this.canvas.width || y >= this.canvas.height) {
                        return;
                    }

                    const buildingType = document.getElementById('buildingType')?.value;
                    if (!buildingType || !this.buildingTypes[buildingType]) {
                        return;
                    }

                    const gridMode = document.getElementById('gridMode')?.value || 'free';
                    
                    // Apply grid constraints
                    const gridPos = this.applyGridConstraints(x, y, gridMode);
                    
                    // Check for overlaps
                    if (this.checkOverlap(gridPos.x, gridPos.y, buildingType)) {
                        return;
                    }
                    
                    // Place building
                    this.placeBuilding(buildingType, gridPos.x, gridPos.y);
                } catch (error) {
                    console.error('Click handler error:', error);
                }
            },

            handleMouseMove(event) {
                try {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = Math.round(event.clientX - rect.left);
                    const y = Math.round(event.clientY - rect.top);
                    
                    const coordDisplay = document.getElementById('coordinates');
                    if (coordDisplay) {
                        coordDisplay.textContent = `Position: (${x}, ${y})`;
                    }
                } catch (error) {
                    // Ignore mouse move errors
                }
            },

            // =================================================================
            // BUILDING PLACEMENT - OPTIMIZED
            // =================================================================

            placeBuilding(type, x, y) {
                try {
                    const buildingDef = this.buildingTypes[type];
                    if (!buildingDef) {
                        console.warn('Unknown building type:', type);
                        return false;
                    }

                    const building = {
                        type: type,
                        x: Math.round(x),
                        y: Math.round(y),
                        size: buildingDef.size,
                        color: buildingDef.color,
                        energy: { ...buildingDef.energy },
                        population: buildingDef.population || 0,
                        emoji: buildingDef.emoji || '🏠',
                        id: Date.now() + Math.random(),
                        isWater: buildingDef.isWater || false,
                        isCrystal: buildingDef.isCrystal || false,
                        isCopper: buildingDef.isCopper || false,
                        isDefense: buildingDef.isDefense || false,
                        isGatorGarden: buildingDef.isGatorGarden || false
                    };

                    this.buildings.push(building);
                    this.needsRedraw = true;
                    this.updateUI();

                    if (this.showEnergyFlowMode) {
                        this.calculateEnergyFlows();
                    }

                    console.log('Building placed:', building);
                    return true;
                } catch (error) {
                    console.error('Building placement error:', error);
                    return false;
                }
            },

            checkOverlap(x, y, buildingType) {
                const buildingSize = this.buildingTypes[buildingType]?.size || 20;
                
                for (const building of this.buildings) {
                    const distance = Math.sqrt(
                        Math.pow(building.x - x, 2) + 
                        Math.pow(building.y - y, 2)
                    );
                    const minDistance = (building.size + buildingSize) / 2 + 5;
                    
                    if (distance < minDistance) {
                        return true;
                    }
                }
                return false;
            },

            // =================================================================
            // GRID SYSTEM - OPTIMIZED AND ORGANIZED
            // =================================================================

            applyGridConstraints(x, y, gridMode) {
                if (!this.canvas || gridMode === 'free') {
                    return { x, y };
                }

                try {
                    const centerX = this.canvas.width / 2;
                    const centerY = this.canvas.height / 2;

                    switch (gridMode) {
                        case 'sacred':
                            return this.snapToSacredGrid(x, y);
                        case 'cross':
                            return this.snapToCrossGrid(x, y);
                        case 'hexagon':
                            return this.snapToHexGrid(x, y);
                        case 'mandala':
                            return this.snapToMandalaGrid(x, y, centerX, centerY);
                        case 'tree':
                            return this.snapToTreeGrid(x, y, centerX, centerY);
                        case 'spiral':
                            return this.snapToSpiralGrid(x, y, centerX, centerY);
                        case 'labyrinth':
                            return this.snapToLabyrinthGrid(x, y, centerX, centerY);
                        case 'spider_web':
                            return this.snapToSpiderWebGrid(x, y, centerX, centerY);
                        case 'nordic_circles':
                            return this.snapToNordicGrid(x, y, centerX, centerY);
                        default:
                            return { x, y };
                    }
                } catch (error) {
                    console.warn('Grid constraint error:', error);
                    return { x, y };
                }
            },

            // Optimized grid snapping functions
            snapToSacredGrid(x, y) {
                const gridSize = 40;
                return {
                    x: Math.round(x / gridSize) * gridSize,
                    y: Math.round(y / gridSize) * gridSize
                };
            },

            snapToCrossGrid(x, y) {
                const gridSize = 50;
                return {
                    x: Math.round(x / gridSize) * gridSize,
                    y: Math.round(y / gridSize) * gridSize
                };
            },

            snapToHexGrid(x, y) {
                const size = 30;
                const height = size * Math.sqrt(3) / 2;
                const col = Math.round(x / (size * 3/4));
                const row = Math.round((y - (col % 2) * height / 2) / height);
                return {
                    x: col * size * 3/4,
                    y: row * height + (col % 2) * height / 2
                };
            },

            snapToMandalaGrid(x, y, centerX, centerY) {
                const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                const angle = Math.atan2(y - centerY, x - centerX);
                const snapAngle = Math.round(angle / (Math.PI / 4)) * (Math.PI / 4);
                const snapRadius = Math.round(distance / 30) * 30;
                return {
                    x: centerX + Math.cos(snapAngle) * snapRadius,
                    y: centerY + Math.sin(snapAngle) * snapRadius
                };
            },

            snapToTreeGrid(x, y, centerX, centerY) {
                const sephiroth = [
                    { x: centerX, y: centerY - 120 },
                    { x: centerX - 50, y: centerY - 70 },
                    { x: centerX + 50, y: centerY - 70 },
                    { x: centerX - 50, y: centerY - 20 },
                    { x: centerX + 50, y: centerY - 20 },
                    { x: centerX, y: centerY },
                    { x: centerX - 50, y: centerY + 50 },
                    { x: centerX + 50, y: centerY + 50 },
                    { x: centerX, y: centerY + 100 },
                    { x: centerX, y: centerY + 150 }
                ];

                let closest = { x, y };
                let minDist = Infinity;

                for (const seph of sephiroth) {
                    if (seph.y >= 0 && seph.y <= this.canvas.height && 
                        seph.x >= 0 && seph.x <= this.canvas.width) {
                        const dist = Math.sqrt(Math.pow(x - seph.x, 2) + Math.pow(y - seph.y, 2));
                        if (dist < minDist && dist < 40) {
                            minDist = dist;
                            closest = seph;
                        }
                    }
                }

                return closest;
            },

            snapToSpiralGrid(x, y, centerX, centerY) {
                const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                const angle = Math.atan2(y - centerY, x - centerX);
                const snapAngle = Math.round(angle / (Math.PI / 4)) * (Math.PI / 4);
                const snapRadius = Math.round(distance / 25) * 25;
                return {
                    x: centerX + Math.cos(snapAngle) * snapRadius,
                    y: centerY + Math.sin(snapAngle) * snapRadius
                };
            },

            snapToLabyrinthGrid(x, y, centerX, centerY) {
                const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                const angle = Math.atan2(y - centerY, x - centerX);
                const snapRadius = Math.round(distance / 30) * 30;
                return {
                    x: centerX + Math.cos(angle) * snapRadius,
                    y: centerY + Math.sin(angle) * snapRadius
                };
            },

            snapToSpiderWebGrid(x, y, centerX, centerY) {
                const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                const angle = Math.atan2(y - centerY, x - centerX);
                const spokeAngle = Math.round(angle / (Math.PI / 6)) * (Math.PI / 6);
                const ringRadius = Math.round(distance / 35) * 35;
                return {
                    x: centerX + Math.cos(spokeAngle) * ringRadius,
                    y: centerY + Math.sin(spokeAngle) * ringRadius
                };
            },

            snapToNordicGrid(x, y, centerX, centerY) {
                const radius = 50;
                const circles = [
                    { x: centerX, y: centerY },
                    { x: centerX - radius, y: centerY },
                    { x: centerX + radius, y: centerY },
                    { x: centerX, y: centerY - radius },
                    { x: centerX, y: centerY + radius },
                    { x: centerX - radius * 0.7, y: centerY - radius * 0.7 },
                    { x: centerX + radius * 0.7, y: centerY - radius * 0.7 },
                    { x: centerX - radius * 0.7, y: centerY + radius * 0.7 },
                    { x: centerX + radius * 0.7, y: centerY + radius * 0.7 }
                ];

                let closest = { x, y };
                let minDist = Infinity;

                for (const circle of circles) {
                    if (circle.y >= 0 && circle.y <= this.canvas.height && 
                        circle.x >= 0 && circle.x <= this.canvas.width) {
                        const dist = Math.sqrt(Math.pow(x - circle.x, 2) + Math.pow(y - circle.y, 2));
                        if (dist < minDist && dist < 35) {
                            minDist = dist;
                            closest = circle;
                        }
                    }
                }

                return closest;
            },

            // =================================================================
            // RENDERING SYSTEM - OPTIMIZED
            // =================================================================

            render() {
                if (!this.ctx || !this.canvas || !this.needsRedraw) return;

                try {
                    // Clear canvas
                    this.ctx.fillStyle = '#1a1a1a';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                    // Draw components
                    this.drawGrid();
                    this.drawBuildings();
                    
                    if (this.showEnergyFlowMode) {
                        this.drawEnergyFlows();
                    }

                    this.needsRedraw = false;
                } catch (error) {
                    console.warn('Render error:', error);
                }
            },

            drawGrid() {
                const gridMode = document.getElementById('gridMode')?.value;
                if (!gridMode || gridMode === 'free') return;

                try {
                    this.ctx.save();
                    this.ctx.strokeStyle = 'rgba(212, 175, 55, 0.5)';
                    this.ctx.lineWidth = 1;
                    this.ctx.fillStyle = 'rgba(212, 175, 55, 0.3)';

                    const centerX = this.canvas.width / 2;
                    const centerY = this.canvas.height / 2;

                    switch (gridMode) {
                        case 'sacred':
                            this.drawSacredGrid();
                            break;
                        case 'cross':
                            this.drawCrossGrid(centerX, centerY);
                            break;
                        case 'hexagon':
                            this.drawHexagonGrid();
                            break;
                        case 'spiral':
                            this.drawSpiralGrid(centerX, centerY);
                            break;
                        case 'mandala':
                            this.drawMandalaGrid(centerX, centerY);
                            break;
                        case 'tree':
                            this.drawTreeGrid(centerX, centerY);
                            break;
                        case 'labyrinth':
                            this.drawLabyrinthGrid(centerX, centerY);
                            break;
                        case 'spider_web':
                            this.drawSpiderWebGrid(centerX, centerY);
                            break;
                        case 'nordic_circles':
                            this.drawNordicCirclesGrid(centerX, centerY);
                            break;
                    }

                    this.ctx.restore();
                } catch (error) {
                    console.warn('Grid drawing error:', error);
                    this.ctx.restore();
                }
            },

            // Optimized grid drawing functions
            drawSacredGrid() {
                const gridSize = 40;
                this.ctx.strokeStyle = 'rgba(212, 175, 55, 0.4)';
                this.ctx.lineWidth = 1;

                // Vertical lines
                for (let x = 0; x <= this.canvas.width; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }

                // Horizontal lines
                for (let y = 0; y <= this.canvas.height; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }

                // Grid points
                this.ctx.fillStyle = 'rgba(212, 175, 55, 0.7)';
                for (let x = 0; x <= this.canvas.width; x += gridSize) {
                    for (let y = 0; y <= this.canvas.height; y += gridSize) {
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, 2, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }
            },

            drawCrossGrid(centerX, centerY) {
                this.ctx.strokeStyle = 'rgba(212, 175, 55, 0.6)';
                this.ctx.lineWidth = 2;

                // Main cross
                this.ctx.beginPath();
                this.ctx.moveTo(centerX, 0);
                this.ctx.lineTo(centerX, this.canvas.height);
                this.ctx.moveTo(0, centerY);
                this.ctx.lineTo(this.canvas.width, centerY);
                this.ctx.stroke();

                // Diagonal cross
                this.ctx.beginPath();
                this.ctx.moveTo(0, 0);
                this.ctx.lineTo(this.canvas.width, this.canvas.height);
                this.ctx.moveTo(this.canvas.width, 0);
                this.ctx.lineTo(0, this.canvas.height);
                this.ctx.stroke();

                // Grid lines
                this.ctx.strokeStyle = 'rgba(212, 175, 55, 0.3)';
                this.ctx.lineWidth = 1;
                const spacing = 50;

                for (let x = spacing; x < this.canvas.width; x += spacing) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }

                for (let y = spacing; y < this.canvas.height; y += spacing) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
            },

            drawHexagonGrid() {
                const size = 30;
                const height = size * Math.sqrt(3) / 2;

                this.ctx.strokeStyle = 'rgba(212, 175, 55, 0.4)';
                this.ctx.lineWidth = 1;

                for (let row = -2; row <= Math.ceil(this.canvas.height / height) + 2; row++) {
                    for (let col = -2; col <= Math.ceil(this.canvas.width / (size * 3/4)) + 2; col++) {
                        const x = col * size * 3/4;
                        const y = row * height + (col % 2) * height / 2;

                        if (x > -size && x < this.canvas.width + size && y > -size && y < this.canvas.height + size) {
                            // Draw hexagon
                            this.ctx.beginPath();
                            for (let i = 0; i < 6; i++) {
                                const angle = (i * Math.PI) / 3;
                                const hx = x + Math.cos(angle) * size / 2;
                                const hy = y + Math.sin(angle) * size / 2;
                                if (i === 0) this.ctx.moveTo(hx, hy);
                                else this.ctx.lineTo(hx, hy);
                            }
                            this.ctx.closePath();
                            this.ctx.stroke();

                            // Center point
                            this.ctx.fillStyle = 'rgba(212, 175, 55, 0.6)';
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, 2, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                }
            },

            drawSpiralGrid(centerX, centerY) {
                this.ctx.strokeStyle = 'rgba(212, 175, 55, 0.6)';
                this.ctx.lineWidth = 2;

                // Draw spiral
                this.ctx.beginPath();
                this.ctx.moveTo(centerX, centerY);

                let radius = 5;
                let angle = 0;

                for (let i = 0; i < 150; i++) {
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;

                    if (x >= 0 && x <= this.canvas.width && y >= 0 && y <= this.canvas.height) {
                        this.ctx.lineTo(x, y);
                    }

                    angle += 0.2;
                    radius += 1.2;

                    if (radius > 300) break;
                }
                this.ctx.stroke();

                // Radial lines
                this.ctx.strokeStyle = 'rgba(212, 175, 55, 0.3)';
                this.ctx.lineWidth = 1;

                for (let i = 0; i < 8; i++) {
                    const lineAngle = (i * Math.PI) / 4;
                    this.ctx.beginPath();
                    this.ctx.moveTo(centerX, centerY);
                    this.ctx.lineTo(
                        centerX + Math.cos(lineAngle) * 250,
                        centerY + Math.sin(lineAngle) * 250
                    );
                    this.ctx.stroke();
                }
            },

            drawMandalaGrid(centerX, centerY) {
                this.ctx.strokeStyle = 'rgba(212, 175, 55, 0.4)';
                this.ctx.lineWidth = 1;

                // Concentric circles
                for (let radius = 30; radius <= 250; radius += 30) {
                    this.ctx.beginPath();
                    this.ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    this.ctx.stroke();
                }

                // Primary radial lines
                this.ctx.lineWidth = 2;
                for (let i = 0; i < 8; i++) {
                    const angle = (i * Math.PI) / 4;
                    this.ctx.beginPath();
                    this.ctx.moveTo(centerX, centerY);
                    this.ctx.lineTo(
                        centerX + Math.cos(angle) * 250,
                        centerY + Math.sin(angle) * 250
                    );
                    this.ctx.stroke();
                }

                // Secondary radial lines
                this.ctx.strokeStyle = 'rgba(212, 175, 55, 0.3)';
                this.ctx.lineWidth = 1;
                for (let i = 0; i < 16; i++) {
                    const angle = (i * Math.PI) / 8;
                    this.ctx.beginPath();
                    this.ctx.moveTo(
                        centerX + Math.cos(angle) * 50,
                        centerY + Math.sin(angle) * 50
                    );
                    this.ctx.lineTo(
                        centerX + Math.cos(angle) * 250,
                        centerY + Math.sin(angle) * 250
                    );
                    this.ctx.stroke();
                }

                // Intersection points
                this.ctx.fillStyle = 'rgba(212, 175, 55, 0.7)';
                for (let radius = 60; radius <= 250; radius += 30) {
                    for (let i = 0; i < 8; i++) {
                        const angle = (i * Math.PI) / 4;
                        const x = centerX + Math.cos(angle) * radius;
                        const y = centerY + Math.sin(angle) * radius;

                        this.ctx.beginPath();
                        this.ctx.arc(x, y, 3, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }
            },

            drawTreeGrid(centerX, centerY) {
                this.ctx.strokeStyle = 'rgba(212, 175, 55, 0.5)';
                this.ctx.lineWidth = 2;

                const sephiroth = [
                    { x: centerX, y: centerY - 120 },
                    { x: centerX - 50, y: centerY - 70 },
                    { x: centerX + 50, y: centerY - 70 },
                    { x: centerX - 50, y: centerY - 20 },
                    { x: centerX + 50, y: centerY - 20 },
                    { x: centerX, y: centerY },
                    { x: centerX - 50, y: centerY + 50 },
                    { x: centerX + 50, y: centerY + 50 },
                    { x: centerX, y: centerY + 100 },
                    { x: centerX, y: centerY + 150 }
                ];

                const paths = [
                    [0,1], [0,2], [1,2], [1,3], [2,4], [3,4], [3,5], [4,5],
                    [5,6], [5,7], [6,7], [6,8], [7,8], [8,9]
                ];

                // Draw paths
                paths.forEach(([a, b]) => {
                    const start = sephiroth[a];
                    const end = sephiroth[b];

                    if (start && end && start.y >= 0 && start.y <= this.canvas.height && 
                        end.y >= 0 && end.y <= this.canvas.height) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(start.x, start.y);
                        this.ctx.lineTo(end.x, end.y);
                        this.ctx.stroke();
                    }
                });

                // Draw sephiroth
                this.ctx.fillStyle = 'rgba(212, 175, 55, 0.3)';
                this.ctx.strokeStyle = 'rgba(212, 175, 55, 0.8)';

                sephiroth.forEach(seph => {
                    if (seph.y >= 0 && seph.y <= this.canvas.height) {
                        this.ctx.beginPath();
                        this.ctx.arc(seph.x, seph.y, 18, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.stroke();

                        this.ctx.fillStyle = 'rgba(212, 175, 55, 1)';
                        this.ctx.beginPath();
                        this.ctx.arc(seph.x, seph.y, 4, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.fillStyle = 'rgba(212, 175, 55, 0.3)';
                    }
                });
            },

            drawLabyrinthGrid(centerX, centerY) {
                this.ctx.strokeStyle = 'rgba(212, 175, 55, 0.4)';
                this.ctx.lineWidth = 2;

                // Concentric circles
                for (let radius = 30; radius <= 250; radius += 30) {
                    this.ctx.beginPath();
                    this.ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    this.ctx.stroke();
                }

                // Radial divisions
                this.ctx.strokeStyle = 'rgba(212, 175, 55, 0.3)';
                this.ctx.lineWidth = 1;

                for (let i = 0; i < 12; i++) {
                    const angle = (i * Math.PI) / 6;
                    this.ctx.beginPath();
                    this.ctx.moveTo(centerX, centerY);
                    this.ctx.lineTo(
                        centerX + Math.cos(angle) * 250,
                        centerY + Math.sin(angle) * 250
                    );
                    this.ctx.stroke();
                }

                // Path markers
                this.ctx.fillStyle = 'rgba(212, 175, 55, 0.6)';
                for (let radius = 30; radius <= 250; radius += 30) {
                    for (let i = 0; i < 12; i++) {
                        const angle = (i * Math.PI) / 6;
                        const x = centerX + Math.cos(angle) * radius;
                        const y = centerY + Math.sin(angle) * radius;

                        this.ctx.beginPath();
                        this.ctx.arc(x, y, 2, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }
            },

            drawSpiderWebGrid(centerX, centerY) {
                this.ctx.strokeStyle = 'rgba(212, 175, 55, 0.5)';
                this.ctx.lineWidth = 2;

                // Web rings
                for (let radius = 35; radius <= 250; radius += 35) {
                    this.ctx.beginPath();
                    this.ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    this.ctx.stroke();
                }

                // Spokes
                this.ctx.strokeStyle = 'rgba(212, 175, 55, 0.4)';
                this.ctx.lineWidth = 1.5;

                for (let i = 0; i < 12; i++) {
                    const angle = (i * Math.PI) / 6;
                    this.ctx.beginPath();
                    this.ctx.moveTo(centerX, centerY);
                    this.ctx.lineTo(
                        centerX + Math.cos(angle) * 250,
                        centerY + Math.sin(angle) * 250
                    );
                    this.ctx.stroke();
                }

                // Droplets at intersections
                this.ctx.fillStyle = 'rgba(212, 175, 55, 0.7)';
                for (let radius = 35; radius <= 250; radius += 35) {
                    for (let i = 0; i < 12; i++) {
                        const angle = (i * Math.PI) / 6;
                        const x = centerX + Math.cos(angle) * radius;
                        const y = centerY + Math.sin(angle) * radius;

                        this.ctx.beginPath();
                        this.ctx.arc(x, y, 3, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }

                // Center spider
                this.ctx.fillStyle = 'rgba(212, 175, 55, 1)';
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, 6, 0, Math.PI * 2);
                this.ctx.fill();
            },

            drawNordicCirclesGrid(centerX, centerY) {
                const radius = 50;

                this.ctx.strokeStyle = 'rgba(212, 175, 55, 0.5)';
                this.ctx.lineWidth = 2;

                const circles = [
                    { x: centerX, y: centerY },
                    { x: centerX - radius, y: centerY },
                    { x: centerX + radius, y: centerY },
                    { x: centerX, y: centerY - radius },
                    { x: centerX, y: centerY + radius },
                    { x: centerX - radius * 0.7, y: centerY - radius * 0.7 },
                    { x: centerX + radius * 0.7, y: centerY - radius * 0.7 },
                    { x: centerX - radius * 0.7, y: centerY + radius * 0.7 },
                    { x: centerX + radius * 0.7, y: centerY + radius * 0.7 }
                ];

                // Draw circles
                circles.forEach(circle => {
                    if (circle.y >= -radius && circle.y <= this.canvas.height + radius && 
                        circle.x >= -radius && circle.x <= this.canvas.width + radius) {
                        this.ctx.beginPath();
                        this.ctx.arc(circle.x, circle.y, radius * 0.7, 0, Math.PI * 2);
                        this.ctx.stroke();
                    }
                });

                // Connection lines
                this.ctx.strokeStyle = 'rgba(212, 175, 55, 0.3)';
                this.ctx.lineWidth = 1;

                const connections = [
                    [0, 1], [0, 2], [0, 3], [0, 4],
                    [1, 5], [1, 7], [2, 6], [2, 8],
                    [3, 5], [3, 6], [4, 7], [4, 8]
                ];

                connections.forEach(([a, b]) => {
                    const start = circles[a];
                    const end = circles[b];

                    if (start && end) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(start.x, start.y);
                        this.ctx.lineTo(end.x, end.y);
                        this.ctx.stroke();
                    }
                });

                // Center points
                this.ctx.fillStyle = 'rgba(212, 175, 55, 0.8)';
                circles.forEach(circle => {
                    if (circle.y >= 0 && circle.y <= this.canvas.height && 
                        circle.x >= 0 && circle.x <= this.canvas.width) {
                        this.ctx.beginPath();
                        this.ctx.arc(circle.x, circle.y, 4, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                });
            },

            drawBuildings() {
                if (!this.ctx) return;

                try {
                    this.buildings.forEach(building => {
                        if (!building || typeof building.x !== 'number' || typeof building.y !== 'number') return;

                        this.ctx.save();

                        // Special effects for different building types
                        if (building.isWater) {
                            this.drawWaterEffect(building);
                        }

                        if (building.isCrystal) {
                            this.drawCrystalEffect(building);
                        }

                        if (building.isCopper) {
                            this.drawCopperEffect(building);
                        }

                        if (building.isDefense) {
                            this.drawDefenseEffect(building);
                        }

                        if (building.isGatorGarden) {
                            this.drawGatorGardenEffect(building);
                        }

                        // Building shadow
                        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                        this.ctx.fillRect(
                            building.x - building.size/2 + 2, 
                            building.y - building.size/2 + 2, 
                            building.size, 
                            building.size
                        );

                        // Building main body
                        this.ctx.fillStyle = building.color || '#666';
                        this.ctx.fillRect(
                            building.x - building.size/2, 
                            building.y - building.size/2, 
                            building.size, 
                            building.size
                        );

                        // Building border
                        this.ctx.strokeStyle = '#f4e8d0';
                        this.ctx.lineWidth = 2;
                        this.ctx.strokeRect(
                            building.x - building.size/2, 
                            building.y - building.size/2, 
                            building.size, 
                            building.size
                        );

                        // Emoji/symbol
                        this.ctx.fillStyle = '#fff';
                        this.ctx.font = `${Math.max(12, building.size * 0.6)}px Arial`;
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';
                        this.ctx.fillText(building.emoji || '🏠', building.x, building.y);

                        // Cathedral special effects
                        if (building.type === 'cathedral') {
                            this.drawCathedralEffect(building);
                        }

                        this.ctx.restore();
                    });
                } catch (error) {
                    console.warn('Building drawing error:', error);
                    this.ctx.restore();
                }
            },

            // =================================================================
            // SPECIAL EFFECTS - OPTIMIZED
            // =================================================================

            drawWaterEffect(building) {
                const waterGradient = this.ctx.createRadialGradient(
                    building.x, building.y, 0,
                    building.x, building.y, building.size * 1.5
                );
                waterGradient.addColorStop(0, 'rgba(64, 224, 208, 0.4)');
                waterGradient.addColorStop(0.7, 'rgba(64, 224, 208, 0.2)');
                waterGradient.addColorStop(1, 'rgba(64, 224, 208, 0)');

                this.ctx.fillStyle = waterGradient;
                this.ctx.beginPath();
                this.ctx.arc(building.x, building.y, building.size * 1.5, 0, Math.PI * 2);
                this.ctx.fill();

                this.ctx.strokeStyle = 'rgba(64, 224, 208, 0.3)';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.arc(building.x, building.y, building.size * 1.2, 0, Math.PI * 2);
                this.ctx.stroke();
                this.ctx.beginPath();
                this.ctx.arc(building.x, building.y, building.size * 1.8, 0, Math.PI * 2);
                this.ctx.stroke();
            },

            drawCrystalEffect(building) {
                const crystalGradient = this.ctx.createRadialGradient(
                    building.x, building.y, 0,
                    building.x, building.y, building.size * 1.4
                );
                crystalGradient.addColorStop(0, 'rgba(186, 85, 211, 0.5)');
                crystalGradient.addColorStop(0.6, 'rgba(147, 112, 219, 0.3)');
                crystalGradient.addColorStop(1, 'rgba(138, 43, 226, 0)');

                this.ctx.fillStyle = crystalGradient;
                this.ctx.beginPath();
                this.ctx.arc(building.x, building.y, building.size * 1.4, 0, Math.PI * 2);
                this.ctx.fill();

                this.ctx.strokeStyle = 'rgba(186, 85, 211, 0.4)';
                this.ctx.lineWidth = 2;
                for (let i = 1; i <= 3; i++) {
                    this.ctx.beginPath();
                    this.ctx.arc(building.x, building.y, building.size * (0.8 + i * 0.3), 0, Math.PI * 2);
                    this.ctx.stroke();
                }
            },

            drawCopperEffect(building) {
                const copperGradient = this.ctx.createRadialGradient(
                    building.x, building.y, 0,
                    building.x, building.y, building.size * 1.3
                );
                copperGradient.addColorStop(0, 'rgba(210, 105, 30, 0.4)');
                copperGradient.addColorStop(0.7, 'rgba(184, 115, 51, 0.2)');
                copperGradient.addColorStop(1, 'rgba(160, 82, 45, 0)');

                this.ctx.fillStyle = copperGradient;
                this.ctx.beginPath();
                this.ctx.arc(building.x, building.y, building.size * 1.3, 0, Math.PI * 2);
                this.ctx.fill();

                this.ctx.strokeStyle = 'rgba(210, 105, 30, 0.3)';
                this.ctx.lineWidth = 1;
                for (let angle = 0; angle < 360; angle += 45) {
                    const radian = (angle * Math.PI) / 180;
                    this.ctx.beginPath();
                    this.ctx.moveTo(
                        building.x + Math.cos(radian) * building.size * 0.6,
                        building.y + Math.sin(radian) * building.size * 0.6
                    );
                    this.ctx.lineTo(
                        building.x + Math.cos(radian) * building.size * 1.2,
                        building.y + Math.sin(radian) * building.size * 1.2
                    );
                    this.ctx.stroke();
                }
            },

            drawDefenseEffect(building) {
                this.ctx.strokeStyle = 'rgba(139, 0, 0, 0.3)';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.arc(building.x, building.y, building.size * 1.6, 0, Math.PI * 2);
                this.ctx.stroke();

                const defenseGradient = this.ctx.createRadialGradient(
                    building.x, building.y, 0,
                    building.x, building.y, building.size * 1.6
                );
                defenseGradient.addColorStop(0, 'rgba(139, 0, 0, 0.1)');
                defenseGradient.addColorStop(1, 'rgba(139, 0, 0, 0)');

                this.ctx.fillStyle = defenseGradient;
                this.ctx.beginPath();
                this.ctx.arc(building.x, building.y, building.size * 1.6, 0, Math.PI * 2);
                this.ctx.fill();
            },

            drawCathedralEffect(building) {
                const gradient = this.ctx.createRadialGradient(
                    building.x, building.y, 0,
                    building.x, building.y, building.size
                );
                gradient.addColorStop(0, 'rgba(212, 175, 55, 0.3)');
                gradient.addColorStop(1, 'rgba(212, 175, 55, 0)');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(
                    building.x - building.size, 
                    building.y - building.size, 
                    building.size * 2, 
                    building.size * 2
                );
            },

            drawGatorGardenEffect(building) {
                // WiFi-like infrared pattern
                const time = Date.now() * 0.001;

                // Outer infrared radiation rings
                this.ctx.strokeStyle = 'rgba(255, 0, 100, 0.6)';
                this.ctx.lineWidth = 3;

                for (let ring = 1; ring <= 5; ring++) {
                    const radius = building.size * (1 + ring * 0.4);
                    const opacity = Math.max(0.1, 0.8 - ring * 0.15 + Math.sin(time * 2 + ring) * 0.2);

                    this.ctx.strokeStyle = `rgba(255, 0, 100, ${opacity})`;
                    this.ctx.beginPath();
                    this.ctx.arc(building.x, building.y, radius, 0, Math.PI * 2);
                    this.ctx.stroke();
                }

                // WiFi signal arcs
                this.ctx.strokeStyle = 'rgba(255, 0, 100, 0.8)';
                this.ctx.lineWidth = 4;

                for (let arc = 1; arc <= 3; arc++) {
                    const radius = building.size * (0.8 + arc * 0.3);
                    const opacity = 0.9 - arc * 0.2 + Math.sin(time * 3 + arc) * 0.1;

                    this.ctx.strokeStyle = `rgba(255, 0, 100, ${opacity})`;

                    // Left arc
                    this.ctx.beginPath();
                    this.ctx.arc(building.x, building.y, radius, Math.PI * 0.6, Math.PI * 1.4);
                    this.ctx.stroke();

                    // Right arc  
                    this.ctx.beginPath();
                    this.ctx.arc(building.x, building.y, radius, Math.PI * 1.6, Math.PI * 0.4);
                    this.ctx.stroke();
                }

                // Central core with pulsing effect
                const coreRadius = building.size * 0.3;
                const pulseIntensity = 0.5 + Math.sin(time * 4) * 0.3;

                const coreGradient = this.ctx.createRadialGradient(
                    building.x, building.y, 0,
                    building.x, building.y, coreRadius
                );
                coreGradient.addColorStop(0, `rgba(255, 0, 100, ${pulseIntensity})`);
                coreGradient.addColorStop(0.7, `rgba(255, 50, 150, ${pulseIntensity * 0.5})`);
                coreGradient.addColorStop(1, 'rgba(255, 0, 100, 0)');

                this.ctx.fillStyle = coreGradient;
                this.ctx.beginPath();
                this.ctx.arc(building.x, building.y, coreRadius * 2, 0, Math.PI * 2);
                this.ctx.fill();

                // Radiating energy lines
                this.ctx.strokeStyle = 'rgba(255, 0, 100, 0.4)';
                this.ctx.lineWidth = 2;

                for (let angle = 0; angle < 360; angle += 30) {
                    const radian = (angle * Math.PI) / 180;
                    const lineLength = building.size * (1.5 + Math.sin(time * 2 + angle * 0.1) * 0.3);

                    this.ctx.beginPath();
                    this.ctx.moveTo(
                        building.x + Math.cos(radian) * building.size * 0.6,
                        building.y + Math.sin(radian) * building.size * 0.6
                    );
                    this.ctx.lineTo(
                        building.x + Math.cos(radian) * lineLength,
                        building.y + Math.sin(radian) * lineLength
                    );
                    this.ctx.stroke();
                }
            },

            // =================================================================
            // ENERGY FLOW SYSTEM
            // =================================================================

            drawEnergyFlows() {
                if (!this.showEnergyFlowMode || !this.ctx) return;

                try {
                    this.ctx.save();
                    this.energyFlows.forEach(flow => {
                        if (flow.from && flow.to && flow.strength > 0) {
                            const gradient = this.ctx.createLinearGradient(
                                flow.from.x, flow.from.y, flow.to.x, flow.to.y
                            );
                            gradient.addColorStop(0, `rgba(212, 175, 55, ${flow.strength})`);
                            gradient.addColorStop(1, `rgba(212, 175, 55, 0.1)`);

                            this.ctx.strokeStyle = gradient;
                            this.ctx.lineWidth = 3 * flow.strength;
                            this.ctx.beginPath();
                            this.ctx.moveTo(flow.from.x, flow.from.y);
                            this.ctx.lineTo(flow.to.x, flow.to.y);
                            this.ctx.stroke();
                        }
                    });
                    this.ctx.restore();
                } catch (error) {
                    console.warn('Energy flow drawing error:', error);
                    this.ctx.restore();
                }
            },

            calculateEnergyFlows() {
                try {
                    this.energyFlows = [];

                    const cathedrals = this.buildings.filter(b => b.type === 'cathedral');

                    cathedrals.forEach(cathedral => {
                        this.buildings.forEach(building => {
                            if (building.id !== cathedral.id) {
                                const distance = Math.sqrt(
                                    Math.pow(building.x - cathedral.x, 2) + 
                                    Math.pow(building.y - cathedral.y, 2)
                                );

                                if (distance < 200 && distance > 0) {
                                    this.energyFlows.push({
                                        from: cathedral,
                                        to: building,
                                        strength: Math.max(0, 1 - distance / 200)
                                    });
                                }
                            }
                        });
                    });
                } catch (error) {
                    console.warn('Energy flow calculation error:', error);
                }
            },

            // =================================================================
            // UI UPDATE FUNCTIONS
            // =================================================================

            updateUI() {
                this.updateCityStats();
                this.updatePrinciples();
            },

            updateCityStats() {
                try {
                    const totalPopulation = this.buildings.reduce((sum, b) => sum + (b.population || 0), 0);
                    const cathedrals = this.buildings.filter(b => b.type === 'cathedral').length;
                    const energyCenters = this.buildings.filter(b => 
                        ['cathedral', 'temple', 'well', 'fountain', 'pond', 'spring', 'waterway', 'library', 'monastery', 'sanctuary', 'plaza', 'crystal_mine', 'crystal_forge', 'gator_garden'].includes(b.type)
                    ).length;

                    const statusEl = document.getElementById('statusText');
                    if (statusEl) {
                        statusEl.innerHTML = 
                            `Population: ${totalPopulation}<br>` +
                            `Buildings: ${this.buildings.length}<br>` +
                            `Cathedrals: ${cathedrals}<br>` +
                            `Energy Centers: ${energyCenters}`;
                    }

                    const totalEnergy = this.buildings.reduce((totals, building) => {
                        if (building.energy) {
                            totals.sacred += building.energy.sacred || 0;
                            totals.harmony += building.energy.harmony || 0;
                            totals.prosperity += building.energy.prosperity || 0;
                            totals.protection += building.energy.protection || 0;
                        }
                        return totals;
                    }, { sacred: 0, harmony: 0, prosperity: 0, protection: 0 });

                    const maxEnergy = Math.max(1, totalEnergy.sacred, totalEnergy.harmony, 
                                             totalEnergy.prosperity, totalEnergy.protection);

                    const energyElements = {
                        sacred: document.getElementById('sacredEnergy'),
                        harmony: document.getElementById('harmonyEnergy'),
                        prosperity: document.getElementById('prosperityEnergy'),
                        protection: document.getElementById('protectionEnergy')
                    };

                    Object.keys(energyElements).forEach(type => {
                        const element = energyElements[type];
                        if (element) {
                            const percentage = Math.min(100, (totalEnergy[type] / maxEnergy) * 100);
                            element.style.width = `${percentage}%`;
                        }
                    });
                } catch (error) {
                    console.warn('City stats update error:', error);
                }
            },

            updatePrinciples() {
                try {
                    const principleEl = document.getElementById('principleText');
                    const gridModeEl = document.getElementById('gridMode');

                    if (!principleEl || !gridModeEl) return;

                    const cathedrals = this.buildings.filter(b => b.type === 'cathedral');
                    const gridMode = gridModeEl.value;

                    const gridDescriptions = {
                        'sacred': "Sacred Geometry grid provides golden ratio proportions for harmonious placement.",
                        'cross': "Cross pattern radiates divine energy from the center in four directions.",
                        'hexagon': "Hexagonal grid follows nature's most efficient structural pattern.",
                        'spiral': "Fibonacci spiral guides organic growth and natural flow.",
                        'mandala': "Mandala pattern creates meditative circular harmony.",
                        'tree': "Tree of Life shows the sacred sephiroth positions of divine emanation.",
                        'labyrinth': "Labyrinth circles guide contemplative pathways.",
                        'spider_web': "Spider web pattern creates interconnected nodes of power and communication.",
                        'nordic_circles': "Nordic circles form ancient runic patterns of protection and wisdom.",
                        'free': "Free placement allows intuitive building following natural instincts."
                    };

                    const gridDescription = gridDescriptions[gridMode] || "";

                    if (cathedrals.length === 0) {
                        principleEl.textContent = `Begin by placing the Cathedral as the sacred nexus of your city. ${gridDescription} Click anywhere to place buildings - the grid serves as a visual guide for sacred proportions.`;
                    } else if (cathedrals.length === 1) {
                        const cathedral = cathedrals[0];
                        const centerX = this.canvas?.width / 2 || 400;
                        const centerY = this.canvas?.height / 2 || 300;
                        const distance = Math.sqrt(Math.pow(cathedral.x - centerX, 2) + Math.pow(cathedral.y - centerY, 2));

                        if (distance < 50) {
                            principleEl.textContent = `Excellent! Your cathedral anchors the city's spiritual center. ${gridDescription} Build temples, wells, and libraries to create secondary energy nodes.`;
                        } else {
                            principleEl.textContent = `Your cathedral establishes a sacred foundation. ${gridDescription} Consider how the geometric patterns can guide the placement of complementary structures.`;
                        }
                    } else {
                        principleEl.textContent = `Multiple cathedrals create a powerful sacred grid. ${gridDescription} Each cathedral forms a nexus of divine energy, harmonizing the material and spiritual realms.`;
                    }
                } catch (error) {
                    console.warn('Principles update error:', error);
                }
            },

            // =================================================================
            // ANIMATION SYSTEM
            // =================================================================

            startAnimation() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
                this.animationLoop();
            },

            animationLoop() {
                if (!this.isInitialized) return;

                try {
                    const currentTime = performance.now();

                    if (currentTime - this.lastRenderTime >= this.frameInterval) {
                        // Only render if there are animated elements or if we need a redraw
                        const shouldRender = this.needsRedraw || 
                                           this.showEnergyFlowMode || 
                                           this.buildings.some(b => b.type === 'cathedral') || 
                                           this.buildings.some(b => b.isGatorGarden);

                        if (shouldRender) {
                            this.render();
                        }

                        this.lastRenderTime = currentTime;
                    }

                    this.animationId = requestAnimationFrame(() => this.animationLoop());
                } catch (error) {
                    console.error('Animation loop error:', error);
                    if (this.animationId) {
                        cancelAnimationFrame(this.animationId);
                        this.animationId = null;
                    }
                }
            },

            // =================================================================
            // GAME CONTROL FUNCTIONS
            // =================================================================

            clearCity() {
                try {
                    this.buildings = [];
                    this.energyFlows = [];
                    this.needsRedraw = true;
                    this.updateUI();
                    console.log('City cleared');
                } catch (error) {
                    console.error('Clear city error:', error);
                }
            },

            toggleEnergyFlow() {
                try {
                    this.showEnergyFlowMode = !this.showEnergyFlowMode;
                    if (this.showEnergyFlowMode) {
                        this.calculateEnergyFlows();
                    }
                    this.needsRedraw = true;
                    console.log('Energy flow mode:', this.showEnergyFlowMode);
                } catch (error) {
                    console.error('Energy flow toggle error:', error);
                }
            },

            generateCity() {
                try {
                    this.clearCity();

                    if (!this.canvas) return;

                    const centerX = this.canvas.width / 2;
                    const centerY = this.canvas.height / 2;

                    console.log('Generating city...');

                    // Place cathedral at center
                    this.placeBuilding('cathedral', centerX, centerY);

                    // Generate buildings in hexagonal pattern
                    const angles = [0, 60, 120, 180, 240, 300];
                    const radiusStep = 80;

                    for (let ring = 1; ring <= 2; ring++) {
                        for (let angle of angles) {
                            const radian = (angle * Math.PI) / 180;
                            const radius = radiusStep * ring;
                            const x = centerX + Math.cos(radian) * radius;
                            const y = centerY + Math.sin(radian) * radius;

                            if (x > 50 && x < this.canvas.width - 50 && y > 50 && y < this.canvas.height - 50) {
                                const buildingTypes = ['house', 'cottage', 'manor', 'market', 'temple', 'workshop', 'garden', 'library', 'fountain', 'villa'];
                                const randomType = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];

                                const offsetX = (Math.random() - 0.5) * 30;
                                const offsetY = (Math.random() - 0.5) * 30;
                                this.placeBuilding(randomType, x + offsetX, y + offsetY);
                            }
                        }
                    }

                    // Add some special buildings
                    if (this.canvas.width > 500 && this.canvas.height > 400) {
                        this.placeBuilding('gator_garden', centerX - 150, centerY + 100);
                        this.placeBuilding('crystal_forge', centerX + 150, centerY - 100);
                        this.placeBuilding('fortress', 100, 100);
                        this.placeBuilding('tower', this.canvas.width - 100, this.canvas.height - 100);
                    }

                    console.log('City generated with', this.buildings.length, 'buildings');
                } catch (error) {
                    console.error('City generation error:', error);
                }
            },

            handleGridChange() {
                this.needsRedraw = true;
                this.updatePrinciples();
            },

            // =================================================================
            // PROMPT GENERATION SYSTEM
            // =================================================================

            generatePrompt() {
                try {
                    const cityAnalysis = this.analyzeCity();
                    const prompt = this.createImagePrompt(cityAnalysis);

                    const promptText = document.getElementById('promptText');
                    const modal = document.getElementById('promptModal');

                    if (promptText && modal) {
                        promptText.value = prompt;
                        modal.style.display = 'block';
                    }
                } catch (error) {
                    console.error('Prompt generation error:', error);
                    alert('Error generating prompt. Please try again.');
                }
            },

            analyzeCity() {
                const gridModeEl = document.getElementById('gridMode');
                const gridMode = gridModeEl ? gridModeEl.value : 'free';

                // Count building types
                const buildingCounts = {};
                const buildingPositions = {};
                let totalPopulation = 0;

                this.buildings.forEach(building => {
                    const type = building.type;
                    buildingCounts[type] = (buildingCounts[type] || 0) + 1;
                    totalPopulation += building.population || 0;

                    if (!buildingPositions[type]) {
                        buildingPositions[type] = [];
                    }

                    // Determine position relative to center
                    const centerX = this.canvas.width / 2;
                    const centerY = this.canvas.height / 2;
                    const relativePos = this.getRelativePosition(building.x, building.y, centerX, centerY);
                    buildingPositions[type].push(relativePos);
                });

                // Calculate energy totals
                const totalEnergy = this.buildings.reduce((totals, building) => {
                    if (building.energy) {
                        totals.sacred += building.energy.sacred || 0;
                        totals.harmony += building.energy.harmony || 0;
                        totals.prosperity += building.energy.prosperity || 0;
                        totals.protection += building.energy.protection || 0;
                    }
                    return totals;
                }, { sacred: 0, harmony: 0, prosperity: 0, protection: 0 });

                // Determine dominant characteristics
                const maxEnergy = Math.max(totalEnergy.sacred, totalEnergy.harmony, 
                                         totalEnergy.prosperity, totalEnergy.protection);
                let dominantEnergy = 'balanced';
                if (maxEnergy > 0) {
                    dominantEnergy = Object.keys(totalEnergy).find(key => totalEnergy[key] === maxEnergy);
                }

                return {
                    gridMode,
                    buildingCounts,
                    buildingPositions,
                    totalPopulation,
                    totalEnergy,
                    dominantEnergy,
                    citySize: this.buildings.length,
                    hasWater: this.buildings.some(b => b.isWater),
                    hasCrystal: this.buildings.some(b => b.isCrystal),
                    hasDefense: this.buildings.some(b => b.isDefense),
                    hasGatorGarden: this.buildings.some(b => b.isGatorGarden)
                };
            },

            getRelativePosition(x, y, centerX, centerY) {
                const deltaX = x - centerX;
                const deltaY = y - centerY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

                if (distance < 50) return 'center';
                if (distance < 150) return 'inner';
                if (distance < 250) return 'middle';
                return 'outer';
            },

            createImagePrompt(analysis) {
                let prompt = "A magnificent ";

                // Grid-based architectural style
                const gridStyles = {
                    'sacred': 'geometrically perfect city built on golden ratio proportions',
                    'cross': 'cruciform city with radiating avenues forming sacred crosses', 
                    'hexagon': 'hexagonal city with honeycomb-like districts',
                    'spiral': 'spiral city following fibonacci curves and organic growth patterns',
                    'mandala': 'circular mandala city with concentric rings and radial symmetries',
                    'tree': 'mystical city built on Tree of Life sacred geometry with ten sephiroth districts',
                    'labyrinth': 'labyrinthine city with winding circular pathways',
                    'spider_web': 'web-like city with interconnected radial networks',
                    'nordic_circles': 'nordic city with overlapping circular districts and runic patterns',
                    'free': 'organically planned city with intuitive natural layout'
                };

                prompt += gridStyles[analysis.gridMode] || 'mystical city';

                // Dominant energy description
                const energyDescriptions = {
                    'sacred': ', radiating divine golden light and spiritual energy',
                    'harmony': ', filled with peaceful gardens and harmonious architecture',
                    'prosperity': ', gleaming with wealth and abundant golden decorations',
                    'protection': ', fortified with mighty walls and defensive towers',
                    'balanced': ', perfectly balanced between spiritual and material realms'
                };

                prompt += energyDescriptions[analysis.dominantEnergy];

                // Cathedral placement
                if (analysis.buildingCounts.cathedral) {
                    const cathedralPos = analysis.buildingPositions.cathedral[0];
                    if (cathedralPos === 'center') {
                        prompt += ". At the heart stands a magnificent golden cathedral with soaring spires";
                    } else {
                        prompt += ". A majestic cathedral dominates the cityscape";
                    }

                    if (analysis.buildingCounts.cathedral > 1) {
                        prompt += `, with ${analysis.buildingCounts.cathedral} sacred cathedrals forming a powerful spiritual grid`;
                    }
                }

                // Building descriptions
                const buildingDescriptions = {
                    'house': 'cozy residential houses',
                    'cottage': 'charming cottages with gardens',
                    'manor': 'elegant manor houses',
                    'villa': 'luxurious villas',
                    'apartment': 'multi-story apartment buildings',
                    'market': 'bustling marketplaces',
                    'temple': 'sacred temples with turquoise domes',
                    'workshop': 'industrial workshops with smoking chimneys',
                    'garden': 'lush sacred gardens',
                    'gator_garden': 'mystical gator gardens radiating infrared energy like wifi signals',
                    'well': 'sacred wells with crystal-clear water',
                    'fountain': 'ornate fountains',
                    'pond': 'serene sacred ponds',
                    'spring': 'natural springs',
                    'waterway': 'flowing waterways',
                    'tower': 'tall watchtowers',
                    'wall': 'defensive stone walls',
                    'gate': 'fortified city gates',
                    'barracks': 'military barracks',
                    'fortress': 'mighty fortresses',
                    'crystal_mine': 'purple crystal mines glowing with mystical energy',
                    'crystal_forge': 'crystal forges with magical purple auras',
                    'copper_mine': 'copper mines',
                    'copper_forge': 'copper forges with bronze metalwork',
                    'library': 'grand libraries filled with ancient knowledge',
                    'monastery': 'peaceful monasteries',
                    'sanctuary': 'crystal sanctuaries pulsing with power',
                    'plaza': 'grand ceremonial plazas'
                };

                // Add major building types
                const majorBuildings = Object.keys(analysis.buildingCounts)
                    .filter(type => type !== 'cathedral' && analysis.buildingCounts[type] > 0)
                    .sort((a, b) => analysis.buildingCounts[b] - analysis.buildingCounts[a])
                    .slice(0, 5);

                if (majorBuildings.length > 0) {
                    prompt += ". The city features ";
                    const descriptions = majorBuildings.map(type => {
                        const count = analysis.buildingCounts[type];
                        const desc = buildingDescriptions[type] || type;
                        return count > 1 ? `${count} ${desc}` : `a ${desc}`;
                    });
                    prompt += descriptions.join(', ');
                }

                // Special features
                if (analysis.hasWater) {
                    prompt += ". Shimmering water features flow throughout, creating turquoise reflections";
                }

                if (analysis.hasCrystal) {
                    prompt += ". Purple crystal formations pulse with magical energy, creating ethereal light";
                }

                if (analysis.hasGatorGarden) {
                    prompt += ". Mysterious gator gardens emit infrared wifi-like energy patterns in concentric waves";
                }

                if (analysis.hasDefense) {
                    prompt += ". Powerful fortifications provide protection with red defensive auras";
                }

                // Population and scale
                if (analysis.totalPopulation > 0) {
                    prompt += `. Home to ${analysis.totalPopulation} inhabitants`;
                }

                // Artistic style
                prompt += ". Rendered in detailed fantasy art style with warm lighting, intricate architecture, and mystical atmosphere. Aerial view showing the complete sacred geometry. Ultra-detailed, 4K quality, cinematic lighting, fantasy digital art.";

                return prompt;
            },

            copyPrompt() {
                try {
                    const promptText = document.getElementById('promptText');
                    if (promptText) {
                        promptText.select();
                        document.execCommand('copy');

                        // Visual feedback
                        const copyBtn = event.target;
                        const originalText = copyBtn.textContent;
                        copyBtn.textContent = '✅ Copied!';
                        setTimeout(() => {
                            copyBtn.textContent = originalText;
                        }, 2000);
                    }
                } catch (error) {
                    console.error('Copy error:', error);
                    alert('Copy failed. Please select and copy manually.');
                }
            },

            regeneratePrompt() {
                this.generatePrompt();
            },

            closePromptModal() {
                const modal = document.getElementById('promptModal');
                if (modal) {
                    modal.style.display = 'none';
                }
            },

            // =================================================================
            // MODAL HANDLING
            // =================================================================

            setupModalHandlers() {
                const modal = document.getElementById('promptModal');
                if (modal) {
                    // Close modal when clicking on the backdrop
                    modal.addEventListener('click', (event) => {
                        if (event.target === modal) {
                            this.closePromptModal();
                        }
                    });
                }

                // Close modal with escape key
                document.addEventListener('keydown', (event) => {
                    if (event.key === 'Escape') {
                        this.closePromptModal();
                    }
                });
            }
        };

        // =================================================================
        // INITIALIZATION
        // =================================================================

        window.addEventListener('load', init);
    </script>

    <!-- Separate Desktop Environment Script -->
    <script>
        // Desktop initialization - runs independently with enhanced debugging
        (function() {
            function initDesktop() {
                console.log('🖥️ Initializing desktop environment...');
                
                try {
                    // Check if status bar exists
                    const statusBar = document.querySelector('.status-bar');
                    if (statusBar) {
                        console.log('✅ Status bar found');
                        statusBar.style.display = 'flex'; // Force display
                    } else {
                        console.error('❌ Status bar not found!');
                    }
                    
                    // Update time immediately and set interval
                    console.log('⏰ Setting up time updates...');
                    updateTime();
                    setInterval(updateTime, 1000);
                    
                    // Set moon phase
                    console.log('🌙 Setting up moon phase...');
                    const moonPhase = getMoonPhase();
                    const moonEmoji = document.getElementById('moon-emoji');
                    const moonPhaseEl = document.getElementById('moon-phase');
                    
                    if (moonEmoji) {
                        moonEmoji.textContent = moonPhase.emoji;
                        console.log('✅ Moon emoji set:', moonPhase.emoji);
                    } else {
                        console.error('❌ Moon emoji element not found');
                    }
                    
                    if (moonPhaseEl) {
                        moonPhaseEl.textContent = moonPhase.name;
                        console.log('✅ Moon phase set:', moonPhase.name);
                    } else {
                        console.error('❌ Moon phase element not found');
                    }
                    
                    // Start runic animations
                    console.log('✨ Starting runic animations...');
                    createHypnoticRunes();
                    
                    console.log('🎉 Desktop environment initialized successfully');
                    
                    // Force a visual check after 1 second
                    setTimeout(() => {
                        const timeEl = document.getElementById('current-time');
                        if (timeEl && timeEl.textContent !== 'Loading...') {
                            console.log('✅ Time is updating properly:', timeEl.textContent);
                        } else {
                            console.error('❌ Time is not updating properly');
                        }
                    }, 1000);
                    
                } catch (error) {
                    console.error('❌ Error in desktop initialization:', error);
                }
            }
            
            // Multiple initialization attempts for reliability
            let initAttempts = 0;
            const maxAttempts = 3;
            
            function attemptInit() {
                initAttempts++;
                console.log(`🔄 Desktop init attempt ${initAttempts}/${maxAttempts}`);
                
                if (document.body) {
                    initDesktop();
                } else if (initAttempts < maxAttempts) {
                    setTimeout(attemptInit, 100);
                } else {
                    console.error('❌ Failed to initialize desktop after multiple attempts');
                }
            }
            
            // Start initialization
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', attemptInit);
            } else {
                attemptInit();
            }
            
            // Backup initialization on window load
            window.addEventListener('load', () => {
                console.log('🔄 Backup desktop init on window load');
                initDesktop();
            });
        })();
