<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GlwG8r Nexus</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono:wght@400&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Share Tech Mono', monospace;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 50%, #0f1a0f 100%);
            min-height: 100vh;
            overflow: hidden;
            position: relative;
        }
        
        .desktop {
            width: 100vw;
            height: 100vh;
            position: relative;
            background-image: 
                radial-gradient(circle at 20% 80%, rgba(0, 255, 0, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(0, 255, 0, 0.03) 0%, transparent 50%),
                linear-gradient(90deg, rgba(0, 255, 0, 0.01) 1px, transparent 1px),
                linear-gradient(0deg, rgba(0, 255, 0, 0.01) 1px, transparent 1px);
            background-size: 
                800px 800px,
                600px 600px,
                20px 20px,
                20px 20px;
            animation: subtle-pulse 8s ease-in-out infinite;
        }
        
        .gator-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.08;
            pointer-events: none;
            background: 
                radial-gradient(ellipse at 65% 75%, rgba(0, 255, 65, 0.3) 0%, transparent 40%),
                radial-gradient(ellipse at 35% 60%, rgba(255, 0, 65, 0.2) 0%, transparent 30%),
                linear-gradient(45deg, rgba(0, 100, 50, 0.1) 0%, transparent 70%);
            filter: contrast(1.5) brightness(0.7);
        }
        
        .gator-backdrop::before {
            content: '';
            position: absolute;
            top: 20%;
            left: 15%;
            width: 70%;
            height: 60%;
            background: linear-gradient(135deg, 
                rgba(0, 255, 65, 0.15) 0%, 
                rgba(0, 150, 40, 0.1) 30%,
                rgba(255, 100, 0, 0.05) 60%,
                transparent 100%);
            clip-path: polygon(20% 40%, 45% 20%, 70% 35%, 80% 60%, 60% 80%, 30% 85%, 10% 70%);
            animation: gator-pulse 8s ease-in-out infinite;
        }
        
        @keyframes gator-pulse {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(1.02); }
        }
        
        @keyframes subtle-pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
        
        .glyph-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.15;
        }
        
        @keyframes rune-appear {
            0% { opacity: 0; transform: scale(0.5) rotate(0deg); }
            20% { opacity: 0.3; transform: scale(1.1) rotate(15deg); }
            50% { opacity: 0.2; transform: scale(1) rotate(0deg); }
            80% { opacity: 0.25; transform: scale(0.95) rotate(-10deg); }
            100% { opacity: 0; transform: scale(0.7) rotate(5deg); }
        }
        
        .hypnotic-rune {
            position: absolute;
            color: #00ff41;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 0 0 15px #00ff41, 0 0 25px #00ff41;
            pointer-events: none;
            animation: rune-appear ease-in-out;
        }
        
        .scan-lines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 255, 0, 0.03) 2px,
                rgba(0, 255, 0, 0.03) 4px
            );
            animation: scan-move 2s linear infinite;
            pointer-events: none;
        }
        
        @keyframes scan-move {
            0% { transform: translateY(0); }
            100% { transform: translateY(4px); }
        }
        
        .terminal-corners {
            position: absolute;
            color: #00ff41;
            font-size: 16px;
            text-shadow: 0 0 5px #00ff41;
            font-weight: bold;
        }
        
        .corner-tl { top: 20px; left: 20px; }
        .corner-tr { top: 20px; right: 20px; }
        .corner-bl { bottom: 20px; left: 20px; }
        .corner-br { bottom: 20px; right: 20px; }
        
        .data-stream {
            position: absolute;
            top: 50px;
            right: 30px;
            color: #00ff41;
            font-size: 10px;
            line-height: 1.2;
            opacity: 0.6;
            text-shadow: 0 0 3px #00ff41;
        }
        
        .grid-lines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 255, 65, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 65, 0.05) 1px, transparent 1px);
            background-size: 50px 50px;
            pointer-events: none;
        }
        
        .central-symbol {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 120px;
            color: #00ff41;
            opacity: 0.08;
            text-shadow: 0 0 30px #00ff41;
            animation: central-pulse 6s ease-in-out infinite;
        }
        
        @keyframes central-pulse {
            0%, 100% { opacity: 0.05; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.12; transform: translate(-50%, -50%) scale(1.02); }
        }
        
        .status-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 28px;
            background: linear-gradient(180deg, #2a2a2a, #1a1a1a);
            border-top: 2px inset #555;
            display: flex;
            align-items: center;
            padding: 0 10px;
            font-size: 11px;
            color: #ccc;
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.1);
            z-index: 1000;
        }
        
        .location-info {
            display: flex;
            align-items: center;
            gap: 15px;
            font-size: 10px;
        }
        
        .info-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .moon-phase {
            font-size: 12px;
        }
        
        .status-item {
            margin-right: 15px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .status-led {
            width: 8px;
            height: 8px;
            background: #00ff41;
            border-radius: 50%;
            box-shadow: 0 0 4px #00ff41;
            animation: led-blink 2s infinite;
        }
        
        @keyframes led-blink {
            0%, 90% { opacity: 1; }
            95% { opacity: 0.3; }
        }
        
        .sapphire-skull-icon {
            background: linear-gradient(135deg, #4c1d95 0%, #7c3aed 30%, #a855f7 60%, #4c1d95 100%) !important;
            border: 1px outset #4c1d95 !important;
            color: #ffffff !important;
            text-shadow: 0 0 8px #7c3aed;
            box-shadow: 0 0 12px rgba(124, 58, 237, 0.4);
        }
        
        .red-diamond-icon {
            background: linear-gradient(135deg, #cc3333 0%, #ff6666 50%, #cc3333 100%) !important;
            border: 1px outset #cc3333 !important;
            color: white !important;
        }
        
        .store-icon {
            background: linear-gradient(135deg, #4a90e2 0%, #c0c0c0 50%, #4a90e2 100%) !important;
            border: 1px outset #4a90e2 !important;
        }
        
        .desktop-icon {
            position: absolute;
            width: 64px;
            text-align: center;
            cursor: pointer;
            user-select: none;
        }
        
        .desktop-icon:hover .icon-image {
            background: rgba(0, 0, 139, 0.3);
        }
        
        .icon-image {
            width: 32px;
            height: 32px;
            background: #c0c0c0;
            border: 1px outset #c0c0c0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            margin: 0 auto 4px;
            box-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .icon-label {
            color: white;
            font-size: 11px;
            text-shadow: 1px 1px 1px #000;
            line-height: 1.2;
            font-family: 'MS Sans Serif', sans-serif;
        }
        
        .window-demo {
            position: absolute;
            top: 15%;
            left: 45%;
            width: 300px;
            height: 200px;
            background: #c0c0c0;
            border: 2px outset #c0c0c0;
            box-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            font-family: 'MS Sans Serif', sans-serif;
            font-size: 11px;
            opacity: 0.7;
        }
        
        .window-title {
            height: 20px;
            background: linear-gradient(90deg, #000080, #0000ff);
            color: white;
            display: flex;
            align-items: center;
            padding: 0 5px;
            font-weight: bold;
        }
        
        .window-content {
            padding: 10px;
            background: #c0c0c0;
            height: calc(100% - 20px);
            color: #000;
            font-family: 'Share Tech Mono', monospace;
            font-size: 9px;
            line-height: 1.3;
        }
        
        .glitch-text {
            color: #00ff41;
            animation: glitch 4s infinite;
        }
        
        @keyframes glitch {
            0%, 98% { color: #00ff41; }
            99% { color: #ff0041; }
        }

        /* GATORTOPIA GAME WINDOW STYLES */
        .game-window {
            display: none;
            position: absolute;
            top: 5%;
            left: 5%;
            width: 90%;
            height: 85%;
            background: #c0c0c0;
            border: 2px outset #c0c0c0;
            box-shadow: 4px 4px 8px rgba(0,0,0,0.5);
            font-family: 'MS Sans Serif', sans-serif;
            z-index: 999;
            min-width: 800px;
            min-height: 600px;
        }

        .game-window-title {
            height: 24px;
            background: linear-gradient(90deg, #000080, #0000ff);
            color: white;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 8px;
            font-weight: bold;
            font-size: 11px;
            cursor: move;
        }

        .window-controls {
            display: flex;
            gap: 2px;
        }

        .window-button {
            width: 16px;
            height: 14px;
            background: #c0c0c0;
            border: 1px outset #c0c0c0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            font-weight: bold;
            cursor: pointer;
            color: #000;
        }

        .window-button:hover {
            background: #e0e0e0;
        }

        .window-button:active {
            border: 1px inset #c0c0c0;
        }

        /* GAME CONTENT STYLES */
        .game-content {
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #2d1810 0%, #4a3625 100%);
            color: #f4e8d0;
            font-family: 'Georgia', serif;
            overflow: auto;
            position: relative;
        }

        .game-content .container {
            max-width: 100%;
            margin: 0;
            padding: 10px;
        }

        .game-content h1 {
            text-align: center;
            color: #d4af37;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 10px;
            font-size: 18px;
        }

        .game-content .subtitle {
            text-align: center;
            font-style: italic;
            margin-bottom: 20px;
            color: #c9a876;
            font-size: 12px;
        }

        .game-content .controls {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            border: 2px solid #d4af37;
        }

        .game-content .control-group {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .game-content .control-group label {
            font-size: 10px;
            color: #d4af37;
            font-weight: bold;
        }

        .game-content button {
            background: linear-gradient(135deg, #d4af37, #b8941f);
            color: #2d1810;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 10px;
            transition: all 0.3s ease;
        }

        .game-content button:hover {
            background: linear-gradient(135deg, #e6c552, #d4af37);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .game-content select, .game-content input {
            background: rgba(0,0,0,0.4);
            color: #f4e8d0;
            border: 1px solid #d4af37;
            padding: 6px;
            border-radius: 3px;
            font-size: 10px;
        }

        .game-content .game-area {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .game-content .canvas-container {
            position: relative;
            border: 3px solid #d4af37;
            border-radius: 10px;
            background: #1a1a1a;
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.3);
            flex: 1;
            min-width: 400px;
        }

        .game-content #gameCanvas {
            display: block;
            cursor: crosshair;
        }

        .game-content .side-panel {
            width: 280px;
            background: rgba(0,0,0,0.4);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #d4af37;
            height: fit-content;
            min-width: 280px;
        }

        .game-content .info-section {
            margin-bottom: 15px;
            padding: 12px;
            background: rgba(212, 175, 55, 0.1);
            border-radius: 8px;
            border-left: 4px solid #d4af37;
        }

        .game-content .info-section h3 {
            margin: 0 0 8px 0;
            color: #d4af37;
            font-size: 12px;
        }

        .game-content .coordinate-display {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(0,0,0,0.7);
            color: #d4af37;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 10px;
            font-family: monospace;
        }

        .game-content .legend {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 8px;
            margin-top: 10px;
        }

        .game-content .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 9px;
        }

        .game-content .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .game-content .energy-meter {
            background: rgba(0,0,0,0.3);
            padding: 6px;
            border-radius: 5px;
            text-align: center;
            font-size: 10px;
        }

        .game-content .energy-bar {
            width: 100%;
            height: 4px;
            background: rgba(0,0,0,0.3);
            border-radius: 3px;
            margin-top: 3px;
            overflow: hidden;
        }

        .game-content .energy-fill {
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 3px;
        }

        .game-content .sacred-meter .energy-fill { background: linear-gradient(90deg, #ff6b35, #f7931e); }
        .game-content .harmony-meter .energy-fill { background: linear-gradient(90deg, #4ecdc4, #44a08d); }
        .game-content .prosperity-meter .energy-fill { background: linear-gradient(90deg, #d4af37, #ffdb4d); }
        .game-content .protection-meter .energy-fill { background: linear-gradient(90deg, #667eea, #764ba2); }

        /* Animation for window opening */
        .game-window.opening {
            animation: window-open 0.3s ease-out;
        }

        @keyframes window-open {
            from {
                transform: scale(0.8);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* Responsive adjustments */
        @media (max-width: 1200px) {
            .game-window {
                width: 95%;
                height: 90%;
                top: 2.5%;
                left: 2.5%;
            }
            
            .game-content .game-area {
                flex-direction: column;
            }
            
            .game-content .canvas-container {
                min-width: 300px;
            }
            
            .game-content .side-panel {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="desktop">
        <div class="gator-backdrop"></div>
        <div class="grid-lines"></div>
        <div class="scan-lines"></div>
        
        <div class="glyph-overlay" id="runic-field"></div>
        
        <div class="central-symbol">‚óä</div>
        
        <div class="terminal-corners corner-tl">‚îå‚îÄ‚îÄ</div>
        <div class="terminal-corners corner-tr">‚îÄ‚îÄ‚îê</div>
        <div class="terminal-corners corner-bl">‚îî‚îÄ‚îÄ</div>
        <div class="terminal-corners corner-br">‚îÄ‚îÄ‚îò</div>
        
        <div class="data-stream">
            <div class="glitch-text">NEURAL.NET.ACCESS</div>
            <div>CPU: 486DX/66MHz</div>
            <div>RAM: 8MB</div>
            <div>CONNECT: 14.4k</div>
            <div>STATUS: <span style="color: #00ff41;">ONLINE</span></div>
            <div style="margin-top: 10px; opacity: 0.4;">
                01001000 01000001<br>
                01000011 01001011<br>
                01000101 01010010
            </div>
        </div>
        
        <div class="desktop-icon" style="top: 80px; left: 80px;" onclick="launchGatortopia()">
            <div class="icon-image">üêä</div>
            <div class="icon-label">gatortopia.exe</div>
        </div>
        
        <a href="https://www.instagram.com/glowgator/" target="_blank" class="desktop-icon" style="top: 160px; left: 80px; text-decoration: none;">
            <div class="icon-image">üì∑</div>
            <div class="icon-label">photos</div>
        </a>
        
        <a href="https://www.youtube.com/@glowg8r" target="_blank" class="desktop-icon" style="top: 240px; left: 80px; text-decoration: none;">
            <div class="icon-image">üìπ</div>
            <div class="icon-label">videos</div>
        </a>
        
        <a href="https://soundcloud.com/glowg8r" target="_blank" class="desktop-icon" style="top: 320px; left: 80px; text-decoration: none;">
            <div class="icon-image">üéµ</div>
            <div class="icon-label">music</div>
        </a>
        
        <a href="https://medium.com/@glowg8r" target="_blank" class="desktop-icon" style="top: 400px; left: 80px; text-decoration: none;">
            <div class="icon-image">üìú</div>
            <div class="icon-label">my vault</div>
        </a>
        
        <a href="https://glowgator.gumroad.com" target="_blank" class="desktop-icon" style="top: 480px; left: 80px; text-decoration: none;">
            <div class="icon-image store-icon">üõí</div>
            <div class="icon-label">my store</div>
        </a>
        
        <a href="https://jemstudios.drr.ac/" target="_blank" class="desktop-icon" style="bottom: 80px; left: 80px; text-decoration: none;">
            <div class="icon-image sapphire-skull-icon">üíé</div>
            <div class="icon-label">jem studios</div>
        </a>
        
        <a href="https://cinnabar.drr.ac" target="_blank" class="desktop-icon" style="bottom: 80px; right: 80px; text-decoration: none;">
            <div class="icon-image red-diamond-icon">‚ô¶Ô∏è</div>
            <div class="icon-label">cinnabar</div>
        </a>
        
        <div class="window-demo">
            <div class="window-title">SYSTEM.EXE - Neural Interface</div>
            <div class="window-content">
                > INITIATE GATOR SYNTHESIS PROTOCOL<br>
                > SCANNING SWAMP BIOMETRICS...<br>
                > SCALE ARMOR: <span class="glitch-text">ACTIVE</span><br>
                > JAW HYDRAULICS: CHARGING<br>
                <br>
                <span style="color: #00ff41;">[ APEX PREDATOR MODE ]</span>
            </div>
        </div>
        
        <!-- GATORTOPIA GAME WINDOW -->
        <div id="gatortopia-window" class="game-window">
            <div class="game-window-title">
                <span>üêä GATORTOPIA.EXE - Geomantic Cathedral City Simulator v1.44.9</span>
                <div class="window-controls">
                    <div class="window-button" onclick="closeGatortopia()">‚úñ</div>
                </div>
            </div>
            <div class="game-content">
                <div class="container">
                    <h1>üêä Geomantic Cathedral City Simulator üêä</h1>
                    <p class="subtitle">Build sacred cities following ancient hermetic principles</p>
                    
                    <div class="controls">
                        <div class="control-group">
                            <label>Building Type</label>
                            <select id="buildingType">
                                <option value="cathedral">‚õ™ Cathedral (Sacred Nexus)</option>
                                <option value="house">üè† House</option>
                                <option value="cottage">üè° Cottage</option>
                                <option value="manor">üèòÔ∏è Manor</option>
                                <option value="villa">üèõÔ∏è Villa</option>
                                <option value="apartment">üè¢ Apartments</option>
                                <option value="market">üè™ Market</option>
                                <option value="temple">üïå Temple</option>
                                <option value="workshop">üî® Workshop</option>
                                <option value="garden">üå≥ Sacred Garden</option>
                                <option value="gator_garden">üêä Gator Garden</option>
                                <option value="well">üåä Sacred Well</option>
                                <option value="fountain">‚õ≤ Fountain</option>
                                <option value="pond">üèûÔ∏è Sacred Pond</option>
                                <option value="spring">üíß Natural Spring</option>
                                <option value="waterway">üåÄ Waterway</option>
                                <option value="tower">üóº Watchtower</option>
                                <option value="wall">üß± Defensive Wall</option>
                                <option value="gate">üö™ City Gate</option>
                                <option value="barracks">‚öîÔ∏è Barracks</option>
                                <option value="fortress">üè∞ Fortress</option>
                                <option value="crystal_mine">üíé Crystal Mine</option>
                                <option value="crystal_forge">üîÆ Crystal Forge</option>
                                <option value="copper_mine">üü´ Copper Mine</option>
                                <option value="copper_forge">üî® Copper Forge</option>
                                <option value="library">üìö Sacred Library</option>
                                <option value="monastery">üèõÔ∏è Monastery</option>
                                <option value="sanctuary">üîÆ Crystal Sanctuary</option>
                                <option value="plaza">üåü Sacred Plaza</option>
                                <option value="quartz_clock_tower">üï∞Ô∏è Quartz Clock Tower</option>
                                <option value="moth_guard">ü¶ã Moth Guard</option>
                                <option value="crystal_skull">üíÄ Crystal Skull</option>
                                <option value="arch">üèõÔ∏è Sacred Arch</option>
                                <option value="tori_gate">‚õ©Ô∏è Tori Gate</option>
                                <option value="obelisk">üóø Obelisk</option>
                                <option value="tree_grove">üå≤ Tree Grove</option>
                                <option value="rock_formation">ü™® Rock Formation</option>
                                <option value="mushroom_circle">üçÑ Mushroom Circle</option>
                                <option value="obsidian_pillar">‚¨õ Obsidian Pillar</option>
                            </select>
                        </div>
                        
                        <div class="control-group">
                            <label>Grid Mode</label>
                            <select id="gridMode" onchange="handleGridModeChange()">
                                <option value="sacred">Sacred Geometry</option>
                                <option value="cross">Cross Pattern</option>
                                <option value="circle">Circle Grid</option>
                                <option value="square">Square Grid</option>
                                <option value="art_deco">Art Deco Bolts</option>
                                <option value="pentagon">Pentagon (5-sided)</option>
                                <option value="hexagon">Hexagon (6-sided)</option>
                                <option value="heptagon">Heptagon (7-sided)</option>
                                <option value="octagon">Octagon (8-sided)</option>
                                <option value="enneagon">Enneagon (9-sided)</option>
                                <option value="decagon">Decagon (10-sided)</option>
                                <option value="hendecagon">Hendecagon (11-sided Star)</option>
                                <option value="spiral">Golden Spiral</option>
                                <option value="mandala">Mandala Pattern</option>
                                <option value="tree">Tree of Life</option>
                                <option value="labyrinth">Labyrinth</option>
                                <option value="spider_web">Spider Web</option>
                                <option value="nordic_circles">Nordic Circles</option>
                                <option value="free">Free Placement</option>
                            </select>
                        </div>
                        
                        <button onclick="clearCity()">üóëÔ∏è Clear City</button>
                        <button onclick="showEnergyFlow()">‚ö° Show Energy Flow</button>
                        <button onclick="generateCity()">üé≤ Generate Sacred City</button>
                        <button onclick="closeGatortopia()">üö™ Exit to Desktop</button>
                    </div>

                    <div class="game-area">
                        <div class="canvas-container">
                            <canvas id="gameCanvas" width="800" height="600"></canvas>
                            <div class="coordinate-display" id="coordinates">Position: (0, 0)</div>
                        </div>
                        
                        <div class="side-panel">
                            <div class="info-section">
                                <h3>üåü City Energies</h3>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 8px;">
                                    <div class="energy-meter sacred-meter">
                                        Sacred Power
                                        <div class="energy-bar">
                                            <div class="energy-fill" id="sacredEnergy" style="width: 0%"></div>
                                        </div>
                                    </div>
                                    <div class="energy-meter harmony-meter">
                                        Harmony
                                        <div class="energy-bar">
                                            <div class="energy-fill" id="harmonyEnergy" style="width: 0%"></div>
                                        </div>
                                    </div>
                                    <div class="energy-meter prosperity-meter">
                                        Prosperity
                                        <div class="energy-bar">
                                            <div class="energy-fill" id="prosperityEnergy" style="width: 0%"></div>
                                        </div>
                                    </div>
                                    <div class="energy-meter protection-meter">
                                        Protection
                                        <div class="energy-bar">
                                            <div class="energy-fill" id="protectionEnergy" style="width: 0%"></div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="info-section">
                                <h3>üìú Geomantic Principles</h3>
                                <p style="font-size: 9px; line-height: 1.3; color: #00ff65;" id="principleText">
                                    Place the Cathedral at the center of your city as the sacred nexus. All energy flows from this heart of spiritual and temporal power.
                                </p>
                            </div>

                            <div class="info-section">
                                <h3>üìä City Status</h3>
                                <p style="font-size: 9px; line-height: 1.3; color: #00ff65;" id="statusText">
                                    Population: 0<br>
                                    Buildings: 0<br>
                                    Cathedrals: 0<br>
                                    Energy Centers: 0
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="status-bar">
            <div class="location-info">
                <div class="info-item">
                    <span>üïê</span>
                    <span id="current-time">Loading...</span>
                </div>
                <div class="info-item">
                    <span id="moon-emoji" class="moon-phase">üåò</span>
                    <span id="moon-phase">Loading...</span>
                </div>
            </div>
            <div style="margin-left: 40px;" class="status-item">
                <div class="status-led"></div>
                NEURAL LINK
            </div>
            <div class="status-item">SYS.CORE.ACCESS</div>
            <div style="margin-left: auto;">GATOR OS v1.44.9</div>
        </div>
    </div>

    <script>
        // CLEAN SIMPLE GAME CODE
        let canvas, ctx;
        let isInitialized = false;
        let animationId = null;
        const buildings = [];
        const energyFlows = [];
        let showEnergyFlowMode = false;

        // Building types with new buildings
        const buildingTypes = {
            cathedral: { 
                color: '#d4af37', size: 40, 
                energy: { sacred: 50, harmony: 30, prosperity: 20, protection: 40 },
                population: 0, emoji: '‚õ™', cost: 1000
            },
            house: { 
                color: '#8b4513', size: 20, 
                energy: { sacred: 5, harmony: 10, prosperity: 5, protection: 5 },
                population: 4, emoji: 'üè†', cost: 100
            },
            cottage: { 
                color: '#daa520', size: 18, 
                energy: { sacred: 8, harmony: 15, prosperity: 3, protection: 3 },
                population: 2, emoji: 'üè°', cost: 80
            },
            manor: { 
                color: '#a0522d', size: 30, 
                energy: { sacred: 10, harmony: 8, prosperity: 15, protection: 8 },
                population: 8, emoji: 'üèòÔ∏è', cost: 300
            },
            villa: { 
                color: '#cd853f', size: 28, 
                energy: { sacred: 15, harmony: 12, prosperity: 20, protection: 10 },
                population: 6, emoji: 'üèõÔ∏è', cost: 250
            },
            apartment: { 
                color: '#696969', size: 25, 
                energy: { sacred: 3, harmony: 5, prosperity: 8, protection: 12 },
                population: 12, emoji: 'üè¢', cost: 200
            },
            market: { 
                color: '#ff6b35', size: 25, 
                energy: { sacred: 0, harmony: 5, prosperity: 25, protection: 5 },
                population: 0, emoji: 'üè™', cost: 300
            },
            temple: { 
                color: '#4ecdc4', size: 30, 
                energy: { sacred: 30, harmony: 25, prosperity: 10, protection: 20 },
                population: 0, emoji: 'üïå', cost: 500
            },
            workshop: { 
                color: '#666', size: 25, 
                energy: { sacred: 0, harmony: 5, prosperity: 15, protection: 10 },
                population: 2, emoji: 'üî®', cost: 200
            },
            garden: { 
                color: '#228b22', size: 20, 
                energy: { sacred: 10, harmony: 20, prosperity: 5, protection: 5 },
                population: 0, emoji: 'üå≥', cost: 150
            },
            gator_garden: { 
                color: '#006400', size: 50, 
                energy: { sacred: 25, harmony: 35, prosperity: 15, protection: 20 },
                population: 0, emoji: 'üêä', cost: 800, isGatorGarden: true
            },
            well: { 
                color: '#1e90ff', size: 15, 
                energy: { sacred: 15, harmony: 15, prosperity: 10, protection: 10 },
                population: 0, emoji: 'üåä', cost: 250, isWater: true
            },
            fountain: { 
                color: '#00ced1', size: 20, 
                energy: { sacred: 10, harmony: 25, prosperity: 15, protection: 8 },
                population: 0, emoji: '‚õ≤', cost: 350, isWater: true
            },
            pond: { 
                color: '#20b2aa', size: 30, 
                energy: { sacred: 20, harmony: 30, prosperity: 10, protection: 15 },
                population: 0, emoji: 'üèûÔ∏è', cost: 400, isWater: true
            },
            spring: { 
                color: '#48cae4', size: 18, 
                energy: { sacred: 25, harmony: 20, prosperity: 8, protection: 12 },
                population: 0, emoji: 'üíß', cost: 300, isWater: true
            },
            waterway: { 
                color: '#0077be', size: 35, 
                energy: { sacred: 15, harmony: 35, prosperity: 20, protection: 15 },
                population: 0, emoji: 'üåÄ', cost: 500, isWater: true
            },
            tower: { 
                color: '#8a2be2', size: 25, 
                energy: { sacred: 5, harmony: 5, prosperity: 5, protection: 30 },
                population: 1, emoji: 'üóº', cost: 400
            },
            wall: { 
                color: '#708090', size: 15, 
                energy: { sacred: 0, harmony: 2, prosperity: 0, protection: 25 },
                population: 0, emoji: 'üß±', cost: 150, isDefense: true
            },
            gate: { 
                color: '#556b2f', size: 20, 
                energy: { sacred: 5, harmony: 8, prosperity: 10, protection: 20 },
                population: 2, emoji: 'üö™', cost: 300, isDefense: true
            },
            barracks: { 
                color: '#8b0000', size: 28, 
                energy: { sacred: 0, harmony: 5, prosperity: 5, protection: 35 },
                population: 8, emoji: '‚öîÔ∏è', cost: 500, isDefense: true
            },
            fortress: { 
                color: '#2f4f4f', size: 35, 
                energy: { sacred: 10, harmony: 5, prosperity: 0, protection: 50 },
                population: 4, emoji: 'üè∞', cost: 800, isDefense: true
            },
            crystal_mine: { 
                color: '#9370db', size: 22, 
                energy: { sacred: 30, harmony: 15, prosperity: 20, protection: 10 },
                population: 3, emoji: 'üíé', cost: 600, isCrystal: true
            },
            crystal_forge: { 
                color: '#ba55d3', size: 26, 
                energy: { sacred: 40, harmony: 25, prosperity: 15, protection: 15 },
                population: 4, emoji: 'üîÆ', cost: 750, isCrystal: true
            },
            copper_mine: { 
                color: '#b87333', size: 20, 
                energy: { sacred: 5, harmony: 10, prosperity: 25, protection: 5 },
                population: 4, emoji: 'üü´', cost: 400, isCopper: true
            },
            copper_forge: { 
                color: '#d2691e', size: 24, 
                energy: { sacred: 8, harmony: 12, prosperity: 30, protection: 8 },
                population: 5, emoji: 'üî®', cost: 500, isCopper: true
            },
            library: { 
                color: '#4b0082', size: 35, 
                energy: { sacred: 35, harmony: 20, prosperity: 15, protection: 15 },
                population: 3, emoji: 'üìö', cost: 600
            },
            monastery: { 
                color: '#800080', size: 30, 
                energy: { sacred: 40, harmony: 35, prosperity: 5, protection: 25 },
                population: 6, emoji: 'üèõÔ∏è', cost: 750
            },
            sanctuary: { 
                color: '#ff1493', size: 25, 
                energy: { sacred: 45, harmony: 30, prosperity: 10, protection: 20 },
                population: 2, emoji: 'üîÆ', cost: 800
            },
            plaza: { 
                color: '#ffd700', size: 40, 
                energy: { sacred: 20, harmony: 40, prosperity: 30, protection: 15 },
                population: 0, emoji: 'üåü', cost: 500
            },
            quartz_clock_tower: { 
                color: '#e6e6fa', size: 35, 
                energy: { sacred: 40, harmony: 25, prosperity: 20, protection: 30 },
                population: 1, emoji: 'üï∞Ô∏è', cost: 900, isQuartz: true
            },
            moth_guard: { 
                color: '#4b0082', size: 25, 
                energy: { sacred: 20, harmony: 15, prosperity: 5, protection: 45 },
                population: 0, emoji: 'ü¶ã', cost: 600, isMothGuard: true
            },
            crystal_skull: { 
                color: '#dda0dd', size: 22, 
                energy: { sacred: 60, harmony: 20, prosperity: 15, protection: 25 },
                population: 0, emoji: 'üíÄ', cost: 1200, isCrystalSkull: true
            },
            arch: { 
                color: '#d2b48c', size: 30, 
                energy: { sacred: 25, harmony: 30, prosperity: 15, protection: 20 },
                population: 0, emoji: 'üèõÔ∏è', cost: 400, isArch: true
            },
            tori_gate: { 
                color: '#dc143c', size: 28, 
                energy: { sacred: 45, harmony: 35, prosperity: 10, protection: 30 },
                population: 0, emoji: '‚õ©Ô∏è', cost: 700, isToriGate: true
            },
            obelisk: { 
                color: '#2f4f4f', size: 20, 
                energy: { sacred: 50, harmony: 15, prosperity: 10, protection: 35 },
                population: 0, emoji: 'üóø', cost: 800, isObelisk: true
            },
            tree_grove: { 
                color: '#006400', size: 45, 
                energy: { sacred: 15, harmony: 50, prosperity: 20, protection: 25 },
                population: 0, emoji: 'üå≤', cost: 650, isTreeGrove: true
            },
            rock_formation: { 
                color: '#708090', size: 35, 
                energy: { sacred: 20, harmony: 25, prosperity: 15, protection: 40 },
                population: 0, emoji: 'ü™®', cost: 500, isRockFormation: true
            },
            mushroom_circle: { 
                color: '#9370db', size: 30, 
                energy: { sacred: 35, harmony: 40, prosperity: 25, protection: 20 },
                population: 0, emoji: 'üçÑ', cost: 550, isMushroomCircle: true
            },
            obsidian_pillar: { 
                color: '#1c1c1c', size: 25, 
                energy: { sacred: 30, harmony: 10, prosperity: 15, protection: 50 },
                population: 0, emoji: '‚¨õ', cost: 750, isObsidianPillar: true
            }
        };

        // Core game functions
        function safeGetElement(id) {
            try {
                return document.getElementById(id);
            } catch (error) {
                console.warn(`Element with id '${id}' not found:`, error);
                return null;
            }
        }

        function safeRender() {
            if (!isInitialized || !ctx || !canvas) return;

            try {
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                drawGrid();
                drawEnergyFlows();
                drawGardenConnections();
                drawBuildings();
                
            } catch (error) {
                console.warn('Render error:', error);
            }
        }

        function drawBuildings() {
            if (!ctx) return;

            try {
                buildings.forEach(building => {
                    if (!building || typeof building.x !== 'number' || typeof building.y !== 'number') return;

                    ctx.save();
                    
                    // Special effects
                    if (building.isWater) drawWaterEffect(building);
                    if (building.isCrystal) drawCrystalEffect(building);
                    if (building.isCopper) drawCopperEffect(building);
                    if (building.isDefense) drawDefenseEffect(building);
                    if (building.isGatorGarden) drawGatorGardenEffect(building);
                    if (building.isQuartz) drawQuartzEffect(building);
                    if (building.isMothGuard) drawMothGuardEffect(building);
                    if (building.isCrystalSkull) drawCrystalSkullEffect(building);
                    if (building.isToriGate) drawToriGateEffect(building);
                    if (building.isObelisk) drawObeliskEffect(building);
                    if (building.isTreeGrove) drawTreeGroveEffect(building);
                    if (building.isMushroomCircle) drawMushroomCircleEffect(building);
                    if (building.isObsidianPillar) drawObsidianPillarEffect(building);
                    
                    // Building shadow
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.fillRect(
                        building.x - building.size/2 + 2, 
                        building.y - building.size/2 + 2, 
                        building.size, 
                        building.size
                    );
                    
                    // Building main body
                    ctx.fillStyle = building.color || '#666';
                    ctx.fillRect(
                        building.x - building.size/2, 
                        building.y - building.size/2, 
                        building.size, 
                        building.size
                    );
                    
                    // Building border
                    ctx.strokeStyle = '#f4e8d0';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(
                        building.x - building.size/2, 
                        building.y - building.size/2, 
                        building.size, 
                        building.size
                    );
                    
                    // Emoji with fallback
                    try {
                        ctx.fillStyle = '#fff';
                        ctx.font = `${Math.max(12, building.size * 0.6)}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(building.emoji || 'üè†', building.x, building.y);
                    } catch (emojiError) {
                        ctx.fillStyle = '#fff';
                        ctx.fillRect(building.x - 3, building.y - 3, 6, 6);
                    }
                    
                    // Cathedral special effects
                    if (building.type === 'cathedral') {
                        drawCathedralEffect(building);
                    }
                    
                    ctx.restore();
                });
            } catch (error) {
                console.warn('Building drawing error:', error);
                ctx.restore();
            }
        }

        // Basic special effects (simplified)
        function drawWaterEffect(building) {
            const waterGradient = ctx.createRadialGradient(
                building.x, building.y, 0,
                building.x, building.y, building.size * 1.5
            );
            waterGradient.addColorStop(0, 'rgba(64, 224, 208, 0.4)');
            waterGradient.addColorStop(1, 'rgba(64, 224, 208, 0)');
            
            ctx.fillStyle = waterGradient;
            ctx.beginPath();
            ctx.arc(building.x, building.y, building.size * 1.5, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawCrystalEffect(building) {
            const crystalGradient = ctx.createRadialGradient(
                building.x, building.y, 0,
                building.x, building.y, building.size * 1.4
            );
            crystalGradient.addColorStop(0, 'rgba(186, 85, 211, 0.5)');
            crystalGradient.addColorStop(1, 'rgba(138, 43, 226, 0)');
            
            ctx.fillStyle = crystalGradient;
            ctx.beginPath();
            ctx.arc(building.x, building.y, building.size * 1.4, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawCopperEffect(building) {
            const copperGradient = ctx.createRadialGradient(
                building.x, building.y, 0,
                building.x, building.y, building.size * 1.3
            );
            copperGradient.addColorStop(0, 'rgba(210, 105, 30, 0.4)');
            copperGradient.addColorStop(1, 'rgba(160, 82, 45, 0)');
            
            ctx.fillStyle = copperGradient;
            ctx.beginPath();
            ctx.arc(building.x, building.y, building.size * 1.3, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawDefenseEffect(building) {
            ctx.strokeStyle = 'rgba(139, 0, 0, 0.3)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(building.x, building.y, building.size * 1.6, 0, Math.PI * 2);
            ctx.stroke();
        }

        function drawCathedralEffect(building) {
            const gradient = ctx.createRadialGradient(
                building.x, building.y, 0,
                building.x, building.y, building.size
            );
            gradient.addColorStop(0, 'rgba(212, 175, 55, 0.3)');
            gradient.addColorStop(1, 'rgba(212, 175, 55, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(
                building.x - building.size, 
                building.y - building.size, 
                building.size * 2, 
                building.size * 2
            );
        }

        function drawGatorGardenEffect(building) {
            const time = Date.now() * 0.001;
            
            ctx.strokeStyle = 'rgba(255, 0, 100, 0.6)';
            ctx.lineWidth = 3;
            
            for (let ring = 1; ring <= 5; ring++) {
                const radius = building.size * (1 + ring * 0.4);
                const opacity = Math.max(0.1, 0.8 - ring * 0.15 + Math.sin(time * 2 + ring) * 0.2);
                
                ctx.strokeStyle = `rgba(255, 0, 100, ${opacity})`;
                ctx.beginPath();
                ctx.arc(building.x, building.y, radius, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        function drawQuartzEffect(building) {
            const time = Date.now() * 0.001;
            
            const quartzGradient = ctx.createRadialGradient(
                building.x, building.y, 0,
                building.x, building.y, building.size * 1.5
            );
            quartzGradient.addColorStop(0, 'rgba(230, 230, 250, 0.5)');
            quartzGradient.addColorStop(1, 'rgba(75, 0, 130, 0)');
            
            ctx.fillStyle = quartzGradient;
            ctx.beginPath();
            ctx.arc(building.x, building.y, building.size * 1.5, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawMothGuardEffect(building) {
            const mothGradient = ctx.createRadialGradient(
                building.x, building.y, 0,
                building.x, building.y, building.size * 1.6
            );
            mothGradient.addColorStop(0, 'rgba(75, 0, 130, 0.4)');
            mothGradient.addColorStop(1, 'rgba(75, 0, 130, 0)');
            
            ctx.fillStyle = mothGradient;
            ctx.beginPath();
            ctx.arc(building.x, building.y, building.size * 1.6, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawCrystalSkullEffect(building) {
            const skullGradient = ctx.createRadialGradient(
                building.x, building.y, 0,
                building.x, building.y, building.size * 2
            );
            skullGradient.addColorStop(0, 'rgba(221, 160, 221, 0.7)');
            skullGradient.addColorStop(1, 'rgba(138, 43, 226, 0)');
            
            ctx.fillStyle = skullGradient;
            ctx.beginPath();
            ctx.arc(building.x, building.y, building.size * 2, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawToriGateEffect(building) {
            const toriGradient = ctx.createRadialGradient(
                building.x, building.y, 0,
                building.x, building.y, building.size * 1.8
            );
            toriGradient.addColorStop(0, 'rgba(220, 20, 60, 0.4)');
            toriGradient.addColorStop(1, 'rgba(220, 20, 60, 0)');
            
            ctx.fillStyle = toriGradient;
            ctx.beginPath();
            ctx.arc(building.x, building.y, building.size * 1.8, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawObeliskEffect(building) {
            const obeliskGradient = ctx.createRadialGradient(
                building.x, building.y, 0,
                building.x, building.y, building.size * 1.4
            );
            obeliskGradient.addColorStop(0, 'rgba(47, 79, 79, 0.5)');
            obeliskGradient.addColorStop(1, 'rgba(47, 79, 79, 0)');
            
            ctx.fillStyle = obeliskGradient;
            ctx.beginPath();
            ctx.arc(building.x, building.y, building.size * 1.4, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawTreeGroveEffect(building) {
            const groveGradient = ctx.createRadialGradient(
                building.x, building.y, 0,
                building.x, building.y, building.size * 2
            );
            groveGradient.addColorStop(0, 'rgba(0, 100, 0, 0.4)');
            groveGradient.addColorStop(1, 'rgba(0, 100, 0, 0)');
            
            ctx.fillStyle = groveGradient;
            ctx.beginPath();
            ctx.arc(building.x, building.y, building.size * 2, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawMushroomCircleEffect(building) {
            const mushroomGradient = ctx.createRadialGradient(
                building.x, building.y, 0,
                building.x, building.y, building.size * 1.6
            );
            mushroomGradient.addColorStop(0, 'rgba(147, 112, 219, 0.4)');
            mushroomGradient.addColorStop(1, 'rgba(75, 0, 130, 0)');
            
            ctx.fillStyle = mushroomGradient;
            ctx.beginPath();
            ctx.arc(building.x, building.y, building.size * 1.6, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawObsidianPillarEffect(building) {
            const obsidianGradient = ctx.createRadialGradient(
                building.x, building.y, 0,
                building.x, building.y, building.size * 1.5
            );
            obsidianGradient.addColorStop(0, 'rgba(28, 28, 28, 0.6)');
            obsidianGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.fillStyle = obsidianGradient;
            ctx.beginPath();
            ctx.arc(building.x, building.y, building.size * 1.5, 0, Math.PI * 2);
            ctx.fill();
        }

        // Garden connection system
        function drawGardenConnections() {
            if (!ctx) return;

            try {
                const gardens = buildings.filter(b => b.type === 'garden');
                
                if (gardens.length < 2) return;

                ctx.save();
                
                ctx.strokeStyle = 'rgba(34, 139, 34, 0.6)';
                ctx.lineWidth = 2;
                
                try {
                    ctx.setLineDash([8, 4]);
                } catch (e) {
                    // Fallback for browsers that don't support setLineDash
                }
                
                const maxConnectionDistance = 250;
                
                for (let i = 0; i < gardens.length; i++) {
                    for (let j = i + 1; j < gardens.length; j++) {
                        const garden1 = gardens[i];
                        const garden2 = gardens[j];
                        
                        const distance = Math.sqrt(
                            Math.pow(garden2.x - garden1.x, 2) + 
                            Math.pow(garden2.y - garden1.y, 2)
                        );
                        
                        if (distance <= maxConnectionDistance) {
                            const time = Date.now() * 0.001;
                            const pulseOpacity = 0.4 + Math.sin(time * 2 + i + j) * 0.2;
                            
                            ctx.strokeStyle = `rgba(34, 139, 34, ${pulseOpacity})`;
                            
                            ctx.beginPath();
                            ctx.moveTo(garden1.x, garden1.y);
                            ctx.lineTo(garden2.x, garden2.y);
                            ctx.stroke();
                            
                            const midX = (garden1.x + garden2.x) / 2;
                            const midY = (garden1.y + garden2.y) / 2;
                            
                            ctx.fillStyle = `rgba(0, 255, 0, ${pulseOpacity * 0.8})`;
                            ctx.font = '12px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText('üçÉ', midX, midY);
                        }
                    }
                }
                
                try {
                    ctx.setLineDash([]);
                } catch (e) {
                    // Ignore if setLineDash not supported
                }
                ctx.restore();
            } catch (error) {
                console.warn('Garden connection drawing error:', error);
                ctx.restore();
            }
        }

        function drawGrid() {
            if (!ctx || !canvas) return;

            try {
                const gridModeEl = safeGetElement('gridMode');
                if (!gridModeEl) return;
                
                const gridMode = gridModeEl.value;
                if (gridMode === 'free') return;
                
                ctx.save();
                
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                ctx.strokeStyle = 'rgba(212, 175, 55, 0.5)';
                ctx.lineWidth = 1;
                
                switch (gridMode) {
                    case 'sacred':
                        drawSacredGrid();
                        break;
                    case 'cross':
                        drawCrossGrid(centerX, centerY);
                        break;
                    case 'circle':
                        drawCircleGrid(centerX, centerY);
                        break;
                    case 'square':
                        drawSquareGrid();
                        break;
                    case 'art_deco':
                        drawArtDecoGrid(centerX, centerY);
                        break;
                    case 'pentagon':
                        drawPolygonGrid(centerX, centerY, 5);
                        break;
                    case 'hexagon':
                        drawHexagonGrid();
                        break;
                    case 'heptagon':
                        drawPolygonGrid(centerX, centerY, 7);
                        break;
                    case 'octagon':
                        drawPolygonGrid(centerX, centerY, 8);
                        break;
                    case 'enneagon':
                        drawPolygonGrid(centerX, centerY, 9);
                        break;
                    case 'decagon':
                        drawPolygonGrid(centerX, centerY, 10);
                        break;
                    case 'hendecagon':
                        drawStarGrid(centerX, centerY, 11);
                        break;
                    case 'spiral':
                        drawSpiralGrid(centerX, centerY);
                        break;
                    case 'mandala':
                        drawMandalaGrid(centerX, centerY);
                        break;
                    case 'tree':
                        drawTreeGrid(centerX, centerY);
                        break;
                    case 'labyrinth':
                        drawLabyrinthGrid(centerX, centerY);
                        break;
                    case 'spider_web':
                        drawSpiderWebGrid(centerX, centerY);
                        break;
                    case 'nordic_circles':
                        drawNordicCirclesGrid(centerX, centerY);
                        break;
                    default:
                        drawSacredGrid();
                }
                
                ctx.restore();
            } catch (error) {
                console.warn('Grid drawing error:', error);
                ctx.restore();
            }
        }

        function drawSacredGrid() {
            const gridSize = 40;
            
            for (let x = 0; x <= canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = 0; y <= canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        function drawCrossGrid(centerX, centerY) {
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.moveTo(centerX, 0);
            ctx.lineTo(centerX, canvas.height);
            ctx.moveTo(0, centerY);
            ctx.lineTo(canvas.width, centerY);
            ctx.stroke();
        }

        function drawCircleGrid(centerX, centerY) {
            for (let radius = 30; radius <= 300; radius += 30) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        function drawSquareGrid() {
            const gridSize = 50;
            
            for (let x = 0; x <= canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = 0; y <= canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        function drawArtDecoGrid(centerX, centerY) {
            // Art Deco style with radiating bolts and stepped patterns
            ctx.strokeStyle = 'rgba(212, 175, 55, 0.6)';
            ctx.lineWidth = 2;
            
            // Central radiating lines
            for (let i = 0; i < 16; i++) {
                const angle = (i * Math.PI) / 8;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + Math.cos(angle) * 250,
                    centerY + Math.sin(angle) * 250
                );
                ctx.stroke();
            }
            
            // Stepped concentric shapes
            ctx.strokeStyle = 'rgba(212, 175, 55, 0.4)';
            ctx.lineWidth = 1;
            
            for (let step = 1; step <= 5; step++) {
                const size = step * 40;
                // Draw stepped rectangles
                ctx.beginPath();
                ctx.rect(centerX - size, centerY - size, size * 2, size * 2);
                ctx.stroke();
                
                // Draw stepped diamonds
                ctx.beginPath();
                ctx.moveTo(centerX, centerY - size * 1.2);
                ctx.lineTo(centerX + size * 0.8, centerY);
                ctx.lineTo(centerX, centerY + size * 1.2);
                ctx.lineTo(centerX - size * 0.8, centerY);
                ctx.closePath();
                ctx.stroke();
            }
        }

        function drawPolygonGrid(centerX, centerY, sides) {
            // Draw concentric regular polygons
            for (let radius = 40; radius <= 250; radius += 40) {
                ctx.beginPath();
                for (let i = 0; i <= sides; i++) {
                    const angle = (i * 2 * Math.PI) / sides - Math.PI / 2;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
            }
            
            // Draw radial lines from center to vertices
            ctx.strokeStyle = 'rgba(212, 175, 55, 0.3)';
            for (let i = 0; i < sides; i++) {
                const angle = (i * 2 * Math.PI) / sides - Math.PI / 2;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + Math.cos(angle) * 250,
                    centerY + Math.sin(angle) * 250
                );
                ctx.stroke();
            }
        }

        function drawStarGrid(centerX, centerY, points) {
            // Draw star pattern for hendecagon
            ctx.strokeStyle = 'rgba(212, 175, 55, 0.6)';
            ctx.lineWidth = 2;
            
            const outerRadius = 200;
            const innerRadius = 80;
            
            // Draw multiple concentric stars
            for (let scale = 0.3; scale <= 1; scale += 0.2) {
                ctx.beginPath();
                for (let i = 0; i <= points * 2; i++) {
                    const angle = (i * Math.PI) / points;
                    const radius = (i % 2 === 0) ? outerRadius * scale : innerRadius * scale;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.closePath();
                ctx.stroke();
            }
            
            // Add connecting lines
            ctx.strokeStyle = 'rgba(212, 175, 55, 0.3)';
            ctx.lineWidth = 1;
            for (let i = 0; i < points; i++) {
                const angle = (i * 2 * Math.PI) / points;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + Math.cos(angle) * outerRadius,
                    centerY + Math.sin(angle) * outerRadius
                );
                ctx.stroke();
            }
        }

        function drawHexagonGrid() {
            const size = 30;
            const height = size * Math.sqrt(3) / 2;
            
            for (let row = -2; row <= Math.ceil(canvas.height / height) + 2; row++) {
                for (let col = -2; col <= Math.ceil(canvas.width / (size * 3/4)) + 2; col++) {
                    const x = col * size * 3/4;
                    const y = row * height + (col % 2) * height / 2;
                    
                    if (x > -size && x < canvas.width + size && y > -size && y < canvas.height + size) {
                        ctx.beginPath();
                        for (let i = 0; i < 6; i++) {
                            const angle = (i * Math.PI) / 3;
                            const hx = x + Math.cos(angle) * size / 2;
                            const hy = y + Math.sin(angle) * size / 2;
                            if (i === 0) ctx.moveTo(hx, hy);
                            else ctx.lineTo(hx, hy);
                        }
                        ctx.closePath();
                        ctx.stroke();
                    }
                }
            }
        }

        function drawMandalaGrid(centerX, centerY) {
            for (let radius = 30; radius <= 250; radius += 30) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            for (let i = 0; i < 8; i++) {
                const angle = (i * Math.PI) / 4;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + Math.cos(angle) * 250,
                    centerY + Math.sin(angle) * 250
                );
                ctx.stroke();
            }
        }

        function drawSpiralGrid(centerX, centerY) {
            ctx.strokeStyle = 'rgba(212, 175, 55, 0.6)';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            
            let radius = 5;
            let angle = 0;
            
            for (let i = 0; i < 150; i++) {
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                
                if (x >= 0 && x <= canvas.width && y >= 0 && y <= canvas.height) {
                    ctx.lineTo(x, y);
                }
                
                angle += 0.2;
                radius += 1.2;
                
                if (radius > 300) break;
            }
            ctx.stroke();

            // Add radial lines
            ctx.strokeStyle = 'rgba(212, 175, 55, 0.3)';
            ctx.lineWidth = 1;
            
            for (let i = 0; i < 8; i++) {
                const lineAngle = (i * Math.PI) / 4;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + Math.cos(lineAngle) * 250,
                    centerY + Math.sin(lineAngle) * 250
                );
                ctx.stroke();
            }
        }

        function drawTreeGrid(centerX, centerY) {
            ctx.strokeStyle = 'rgba(212, 175, 55, 0.5)';
            ctx.lineWidth = 2;
            
            const sephiroth = [
                { x: centerX, y: centerY - 120 },
                { x: centerX - 50, y: centerY - 70 },
                { x: centerX + 50, y: centerY - 70 },
                { x: centerX - 50, y: centerY - 20 },
                { x: centerX + 50, y: centerY - 20 },
                { x: centerX, y: centerY },
                { x: centerX - 50, y: centerY + 50 },
                { x: centerX + 50, y: centerY + 50 },
                { x: centerX, y: centerY + 100 },
                { x: centerX, y: centerY + 150 }
            ];
            
            const paths = [
                [0,1], [0,2], [1,2], [1,3], [2,4], [3,4], [3,5], [4,5],
                [5,6], [5,7], [6,7], [6,8], [7,8], [8,9]
            ];
            
            // Draw paths
            paths.forEach(([a, b]) => {
                const start = sephiroth[a];
                const end = sephiroth[b];
                
                if (start && end && start.y >= 0 && start.y <= canvas.height && 
                    end.y >= 0 && end.y <= canvas.height) {
                    ctx.beginPath();
                    ctx.moveTo(start.x, start.y);
                    ctx.lineTo(end.x, end.y);
                    ctx.stroke();
                }
            });
            
            // Draw sephiroth circles
            ctx.fillStyle = 'rgba(212, 175, 55, 0.3)';
            ctx.strokeStyle = 'rgba(212, 175, 55, 0.8)';
            
            sephiroth.forEach(seph => {
                if (seph.y >= 0 && seph.y <= canvas.height) {
                    ctx.beginPath();
                    ctx.arc(seph.x, seph.y, 18, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.fillStyle = 'rgba(212, 175, 55, 1)';
                    ctx.beginPath();
                    ctx.arc(seph.x, seph.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'rgba(212, 175, 55, 0.3)';
                }
            });
        }

        function drawLabyrinthGrid(centerX, centerY) {
            ctx.strokeStyle = 'rgba(212, 175, 55, 0.4)';
            ctx.lineWidth = 2;
            
            // Concentric circles
            for (let radius = 30; radius <= 250; radius += 30) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Radial divisions
            ctx.strokeStyle = 'rgba(212, 175, 55, 0.3)';
            ctx.lineWidth = 1;
            
            for (let i = 0; i < 12; i++) {
                const angle = (i * Math.PI) / 6;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + Math.cos(angle) * 250,
                    centerY + Math.sin(angle) * 250
                );
                ctx.stroke();
            }
            
            // Path markers
            ctx.fillStyle = 'rgba(212, 175, 55, 0.6)';
            for (let radius = 30; radius <= 250; radius += 30) {
                for (let i = 0; i < 12; i++) {
                    const angle = (i * Math.PI) / 6;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function drawSpiderWebGrid(centerX, centerY) {
            ctx.strokeStyle = 'rgba(212, 175, 55, 0.5)';
            ctx.lineWidth = 2;
            
            // Web rings
            for (let radius = 35; radius <= 250; radius += 35) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Spokes
            ctx.strokeStyle = 'rgba(212, 175, 55, 0.4)';
            ctx.lineWidth = 1.5;
            
            for (let i = 0; i < 12; i++) {
                const angle = (i * Math.PI) / 6;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + Math.cos(angle) * 250,
                    centerY + Math.sin(angle) * 250
                );
                ctx.stroke();
            }
            
            // Droplets at intersections
            ctx.fillStyle = 'rgba(212, 175, 55, 0.7)';
            for (let radius = 35; radius <= 250; radius += 35) {
                for (let i = 0; i < 12; i++) {
                    const angle = (i * Math.PI) / 6;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Center spider
            ctx.fillStyle = 'rgba(212, 175, 55, 1)';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 6, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawNordicCirclesGrid(centerX, centerY) {
            const radius = 50;
            
            ctx.strokeStyle = 'rgba(212, 175, 55, 0.5)';
            ctx.lineWidth = 2;
            
            const circles = [
                { x: centerX, y: centerY },
                { x: centerX - radius, y: centerY },
                { x: centerX + radius, y: centerY },
                { x: centerX, y: centerY - radius },
                { x: centerX, y: centerY + radius },
                { x: centerX - radius * 0.7, y: centerY - radius * 0.7 },
                { x: centerX + radius * 0.7, y: centerY - radius * 0.7 },
                { x: centerX - radius * 0.7, y: centerY + radius * 0.7 },
                { x: centerX + radius * 0.7, y: centerY + radius * 0.7 }
            ];
            
            // Draw circles
            circles.forEach(circle => {
                if (circle.y >= -radius && circle.y <= canvas.height + radius && 
                    circle.x >= -radius && circle.x <= canvas.width + radius) {
                    ctx.beginPath();
                    ctx.arc(circle.x, circle.y, radius * 0.7, 0, Math.PI * 2);
                    ctx.stroke();
                }
            });
            
            // Connection lines
            ctx.strokeStyle = 'rgba(212, 175, 55, 0.3)';
            ctx.lineWidth = 1;
            
            const connections = [
                [0, 1], [0, 2], [0, 3], [0, 4],
                [1, 5], [1, 7], [2, 6], [2, 8],
                [3, 5], [3, 6], [4, 7], [4, 8]
            ];
            
            connections.forEach(([a, b]) => {
                const start = circles[a];
                const end = circles[b];
                
                if (start && end) {
                    ctx.beginPath();
                    ctx.moveTo(start.x, start.y);
                    ctx.lineTo(end.x, end.y);
                    ctx.stroke();
                }
            });
            
            // Center points
            ctx.fillStyle = 'rgba(212, 175, 55, 0.8)';
            circles.forEach(circle => {
                if (circle.y >= 0 && circle.y <= canvas.height && 
                    circle.x >= 0 && circle.x <= canvas.width) {
                    ctx.beginPath();
                    ctx.arc(circle.x, circle.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }

        function drawEnergyFlows() {
            if (!showEnergyFlowMode || !ctx) return;
            
            try {
                ctx.save();
                energyFlows.forEach(flow => {
                    if (flow.from && flow.to && flow.strength > 0) {
                        const gradient = ctx.createLinearGradient(
                            flow.from.x, flow.from.y, flow.to.x, flow.to.y
                        );
                        gradient.addColorStop(0, `rgba(212, 175, 55, ${flow.strength})`);
                        gradient.addColorStop(1, `rgba(212, 175, 55, 0.1)`);
                        
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = 3 * flow.strength;
                        ctx.beginPath();
                        ctx.moveTo(flow.from.x, flow.from.y);
                        ctx.lineTo(flow.to.x, flow.to.y);
                        ctx.stroke();
                    }
                });
                ctx.restore();
            } catch (error) {
                console.warn('Energy flow drawing error:', error);
                ctx.restore();
            }
        }

        // Animation loop
        let lastRenderTime = 0;
        const frameInterval = 33; // 30 FPS

        function animationLoop(currentTime) {
            if (!isInitialized) return;

            try {
                if (currentTime - lastRenderTime >= frameInterval) {
                    const shouldRender = showEnergyFlowMode || 
                                       buildings.some(b => b.type === 'cathedral') || 
                                       buildings.some(b => b.isGatorGarden) ||
                                       buildings.some(b => b.isQuartz) ||
                                       buildings.some(b => b.isMothGuard) ||
                                       buildings.some(b => b.isCrystalSkull) ||
                                       buildings.some(b => b.isMushroomCircle) ||
                                       buildings.some(b => b.isObsidianPillar) ||
                                       buildings.some(b => b.type === 'garden') ||
                                       buildings.length === 0;
                    
                    if (shouldRender) {
                        safeRender();
                    }
                    lastRenderTime = currentTime;
                }
                
                animationId = requestAnimationFrame(animationLoop);
            } catch (error) {
                console.warn('Animation loop error:', error);
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
            }
        }

        // Event handlers
        function handleCanvasClick(event) {
            if (!isInitialized || !canvas || !ctx) return;

            try {
                const rect = canvas.getBoundingClientRect();
                const x = Math.round(event.clientX - rect.left);
                const y = Math.round(event.clientY - rect.top);
                
                if (x < 0 || y < 0 || x >= canvas.width || y >= canvas.height) return;

                const buildingSelect = document.getElementById('buildingType');
                if (!buildingSelect) return;
                const buildingType = buildingSelect.value;

                placeBuilding(buildingType, x, y);
                
            } catch (error) {
                console.error('Click handler error:', error);
            }
        }

        function handleMouseMove(event) {
            if (!canvas) return;

            try {
                const rect = canvas.getBoundingClientRect();
                const x = Math.round(event.clientX - rect.left);
                const y = Math.round(event.clientY - rect.top);
                
                const coordDisplay = document.getElementById('coordinates');
                if (coordDisplay) {
                    coordDisplay.textContent = `Position: (${x}, ${y})`;
                }
            } catch (error) {
                // Ignore mouse move errors
            }
        }

        // Building placement
        function placeBuilding(type, x, y) {
            try {
                if (!buildingTypes[type]) {
                    console.warn('Unknown building type:', type);
                    return false;
                }
                
                if (x < 0 || y < 0 || x >= canvas.width || y >= canvas.height) {
                    return false;
                }
                
                const building = {
                    type: type,
                    x: Math.round(x),
                    y: Math.round(y),
                    size: buildingTypes[type].size,
                    color: buildingTypes[type].color,
                    energy: { ...buildingTypes[type].energy },
                    population: buildingTypes[type].population || 0,
                    emoji: buildingTypes[type].emoji || 'üè†',
                    id: Date.now() + Math.random(),
                    isWater: buildingTypes[type].isWater || false,
                    isCrystal: buildingTypes[type].isCrystal || false,
                    isCopper: buildingTypes[type].isCopper || false,
                    isDefense: buildingTypes[type].isDefense || false,
                    isGatorGarden: buildingTypes[type].isGatorGarden || false,
                    isQuartz: buildingTypes[type].isQuartz || false,
                    isMothGuard: buildingTypes[type].isMothGuard || false,
                    isCrystalSkull: buildingTypes[type].isCrystalSkull || false,
                    isArch: buildingTypes[type].isArch || false,
                    isToriGate: buildingTypes[type].isToriGate || false,
                    isObelisk: buildingTypes[type].isObelisk || false,
                    isTreeGrove: buildingTypes[type].isTreeGrove || false,
                    isRockFormation: buildingTypes[type].isRockFormation || false,
                    isMushroomCircle: buildingTypes[type].isMushroomCircle || false,
                    isObsidianPillar: buildingTypes[type].isObsidianPillar || false
                };
                
                buildings.push(building);
                
                updateCityStats();
                updatePrinciples();
                safeRender();
                
                return true;
            } catch (error) {
                console.error('Building placement error:', error);
                return false;
            }
        }

        // Game initialization
        function initializeGame() {
            console.log('Starting game initialization...');
            
            try {
                canvas = document.getElementById('gameCanvas');
                if (!canvas) {
                    console.error('Canvas not found');
                    return false;
                }

                ctx = canvas.getContext('2d');
                if (!ctx) {
                    console.error('Cannot get 2D context');
                    return false;
                }

                buildings.length = 0;
                energyFlows.length = 0;
                showEnergyFlowMode = false;
                
                canvas.onclick = handleCanvasClick;
                canvas.onmousemove = handleMouseMove;

                isInitialized = true;
                
                safeRender();
                updateCityStats();
                updatePrinciples();
                
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }
                animationId = requestAnimationFrame(animationLoop);
                
                console.log('Game initialization successful');
                return true;
                
            } catch (error) {
                console.error('Game initialization failed:', error);
                return false;
            }
        }

        function updateCityStats() {
            try {
                const totalPopulation = buildings.reduce((sum, b) => sum + (b.population || 0), 0);
                const cathedrals = buildings.filter(b => b.type === 'cathedral').length;
                const energyCenters = buildings.filter(b => 
                    ['cathedral', 'temple', 'well', 'fountain', 'pond', 'spring', 'waterway', 'library', 'monastery', 'sanctuary', 'plaza', 'crystal_mine', 'crystal_forge', 'gator_garden', 'quartz_clock_tower', 'crystal_skull', 'tori_gate', 'obelisk', 'tree_grove', 'mushroom_circle'].includes(b.type)
                ).length;
                
                const statusEl = safeGetElement('statusText');
                if (statusEl) {
                    statusEl.innerHTML = 
                        `Population: ${totalPopulation}<br>` +
                        `Buildings: ${buildings.length}<br>` +
                        `Cathedrals: ${cathedrals}<br>` +
                        `Energy Centers: ${energyCenters}`;
                }
                
                const totalEnergy = buildings.reduce((totals, building) => {
                    if (building.energy) {
                        totals.sacred += building.energy.sacred || 0;
                        totals.harmony += building.energy.harmony || 0;
                        totals.prosperity += building.energy.prosperity || 0;
                        totals.protection += building.energy.protection || 0;
                    }
                    return totals;
                }, { sacred: 0, harmony: 0, prosperity: 0, protection: 0 });
                
                const maxEnergy = Math.max(1, totalEnergy.sacred, totalEnergy.harmony, 
                                         totalEnergy.prosperity, totalEnergy.protection);
                
                const energyElements = {
                    sacred: safeGetElement('sacredEnergy'),
                    harmony: safeGetElement('harmonyEnergy'),
                    prosperity: safeGetElement('prosperityEnergy'),
                    protection: safeGetElement('protectionEnergy')
                };
                
                Object.keys(energyElements).forEach(type => {
                    const element = energyElements[type];
                    if (element) {
                        const percentage = Math.min(100, (totalEnergy[type] / maxEnergy) * 100);
                        element.style.width = `${percentage}%`;
                    }
                });
            } catch (error) {
                console.warn('City stats update error:', error);
            }
        }

        function updatePrinciples() {
            try {
                const principleEl = safeGetElement('principleText');
                if (!principleEl) return;
                
                const cathedrals = buildings.filter(b => b.type === 'cathedral');
                
                if (cathedrals.length === 0) {
                    principleEl.textContent = `Begin by placing the Cathedral as the sacred nexus of your city. Click anywhere to place buildings - the grid serves as a visual guide for sacred proportions.`;
                } else if (cathedrals.length === 1) {
                    principleEl.textContent = `Excellent! Your cathedral anchors the city's spiritual center. Build temples, wells, and libraries to create secondary energy nodes.`;
                } else {
                    principleEl.textContent = `Multiple cathedrals create a powerful sacred grid. Each cathedral forms a nexus of divine energy, harmonizing the material and spiritual realms.`;
                }
            } catch (error) {
                console.warn('Principles update error:', error);
            }
        }

        function calculateEnergyFlows() {
            try {
                energyFlows.length = 0;
                
                const cathedrals = buildings.filter(b => b.type === 'cathedral');
                
                cathedrals.forEach(cathedral => {
                    buildings.forEach(building => {
                        if (building.id !== cathedral.id) {
                            const distance = Math.sqrt(
                                Math.pow(building.x - cathedral.x, 2) + 
                                Math.pow(building.y - cathedral.y, 2)
                            );
                            
                            if (distance < 200 && distance > 0) {
                                energyFlows.push({
                                    from: cathedral,
                                    to: building,
                                    strength: Math.max(0, 1 - distance / 200)
                                });
                            }
                        }
                    });
                });
            } catch (error) {
                console.warn('Energy flow calculation error:', error);
            }
        }

        // Desktop scripts
        function updateTime() {
            try {
                const now = new Date();
                const timeStr = now.toLocaleTimeString('en-US', { 
                    hour: 'numeric', 
                    minute: '2-digit',
                    hour12: true 
                });
                const timeElement = document.getElementById('current-time');
                if (timeElement) {
                    timeElement.textContent = timeStr;
                }
            } catch (error) {
                console.warn('Time update error:', error);
            }
        }
        
        function getMoonPhase() {
            const today = new Date();
            const year = today.getFullYear();
            const month = today.getMonth() + 1;
            const day = today.getDate();
            
            const c = Math.floor((year - 1900) / 100);
            const e = 2 * (year - 1900 - 100 * c);
            const jd = 365.25 * (year - 1900) + 30.6 * month + day - 0.75 * c + 1;
            const b = (jd - 2451550.1) / 29.530588853;
            const phase = (b - Math.floor(b)) * 29.530588853;
            
            if (phase < 1.84566) return { emoji: 'üåë', name: 'New Moon' };
            else if (phase < 5.53699) return { emoji: 'üåí', name: 'Waxing Crescent' };
            else if (phase < 9.22831) return { emoji: 'üåì', name: 'First Quarter' };
            else if (phase < 12.91963) return { emoji: 'üåî', name: 'Waxing Gibbous' };
            else if (phase < 16.61096) return { emoji: 'üåï', name: 'Full Moon' };
            else if (phase < 20.30228) return { emoji: 'üåñ', name: 'Waning Gibbous' };
            else if (phase < 23.99361) return { emoji: 'üåó', name: 'Last Quarter' };
            else if (phase < 27.68493) return { emoji: 'üåò', name: 'Waning Crescent' };
            else return { emoji: 'üåë', name: 'New Moon' };
        }

        function createHypnoticRunes() {
            const runes = ['·ö†', '·ö¢', '·õâ', '·õü'];
            const runicField = document.getElementById('runic-field');
            
            if (!runicField) return;
            
            const rhythms = [3200, 4700, 2900, 5100, 3800, 4200];
            
            function spawnRune() {
                try {
                    const rune = document.createElement('div');
                    rune.className = 'hypnotic-rune';
                    rune.textContent = runes[Math.floor(Math.random() * runes.length)];
                    
                    const x = Math.random() * 60 + 20;
                    const y = Math.random() * 60 + 20;
                    
                    rune.style.left = x + '%';
                    rune.style.top = y + '%';
                    
                    const duration = Math.random() * 2000 + 3000;
                    rune.style.animationDuration = duration + 'ms';
                    
                    runicField.appendChild(rune);
                    
                    setTimeout(() => {
                        if (rune.parentNode) {
                            rune.parentNode.removeChild(rune);
                        }
                    }, duration);
                } catch (error) {
                    console.warn('Rune spawning error:', error);
                }
            }
            
            rhythms.forEach((interval, index) => {
                setTimeout(() => {
                    spawnRune();
                    setInterval(spawnRune, interval);
                }, index * 800);
            });
        }

        function init() {
            updateTime();
            setInterval(updateTime, 1000);
            
            const moonPhase = getMoonPhase();
            const moonEmoji = document.getElementById('moon-emoji');
            const moonPhaseEl = document.getElementById('moon-phase');
            
            if (moonEmoji && moonPhaseEl) {
                moonEmoji.textContent = moonPhase.emoji;
                moonPhaseEl.textContent = moonPhase.name;
            }
            
            createHypnoticRunes();
        }

        // GLOBAL FUNCTIONS (CLEAN AND SIMPLE)
        function launchGatortopia() {
            console.log('Launching Gatortopia...');
            const gameWindow = document.getElementById('gatortopia-window');
            if (gameWindow) {
                gameWindow.style.display = 'block';
                gameWindow.classList.add('opening');
                
                setTimeout(() => {
                    const success = initializeGame();
                    if (success) {
                        console.log('Gatortopia launched successfully');
                    } else {
                        console.error('Failed to launch Gatortopia');
                    }
                }, 300);
            }
        }

        function closeGatortopia() {
            console.log('Closing Gatortopia...');
            const gameWindow = document.getElementById('gatortopia-window');
            if (gameWindow) {
                gameWindow.style.display = 'none';
                gameWindow.classList.remove('opening');
                
                isInitialized = false;
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
                buildings.length = 0;
                energyFlows.length = 0;
            }
        }

        function clearCity() {
            try {
                buildings.length = 0;
                energyFlows.length = 0;
                updateCityStats();
                updatePrinciples();
                safeRender();
            } catch (error) {
                console.error('Clear city error:', error);
            }
        }

        function showEnergyFlow() {
            try {
                showEnergyFlowMode = !showEnergyFlowMode;
                if (showEnergyFlowMode) {
                    calculateEnergyFlows();
                }
                safeRender();
            } catch (error) {
                console.error('Energy flow toggle error:', error);
            }
        }

        function generateCity() {
            try {
                clearCity();
                
                if (!canvas) return;
                
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                placeBuilding('cathedral', centerX, centerY);
                
                const angles = [0, 60, 120, 180, 240, 300];
                const radiusStep = 80;
                
                for (let ring = 1; ring <= 2; ring++) {
                    for (let angle of angles) {
                        const radian = (angle * Math.PI) / 180;
                        const radius = radiusStep * ring;
                        const x = centerX + Math.cos(radian) * radius;
                        const y = centerY + Math.sin(radian) * radius;
                        
                        if (x > 50 && x < canvas.width - 50 && y > 50 && y < canvas.height - 50) {
                            const buildingTypes = ['house', 'cottage', 'manor', 'market', 'temple', 'workshop', 'garden', 'library', 'fountain', 'villa'];
                            const randomType = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];
                            
                            const offsetX = (Math.random() - 0.5) * 30;
                            const offsetY = (Math.random() - 0.5) * 30;
                            placeBuilding(randomType, x + offsetX, y + offsetY);
                        }
                    }
                }
                
                if (canvas.width > 500 && canvas.height > 400) {
                    placeBuilding('gator_garden', centerX - 150, centerY + 100);
                    placeBuilding('crystal_forge', centerX + 150, centerY - 100);
                    placeBuilding('fortress', 100, 100);
                    placeBuilding('tower', canvas.width - 100, canvas.height - 100);
                }
                
            } catch (error) {
                console.error('City generation error:', error);
            }
        }

        function handleGridModeChange() {
            safeRender();
        }

        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
